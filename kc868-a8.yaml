substitutions:
  name: hideaways

esphome:
  name: ${name}
  name_add_mac_suffix: false
  project:
    name: kincony.kc868-a8
    version: "1.01"
  on_boot:
    priority: 600
    then:
      - switch.turn_off: relay2

esp32:
  board: esp32dev
  framework:
    type: arduino

# Persist writes quickly so learned slots survive power loss
preferences:
  flash_write_interval: 5s

# ---------- Built-in Web UI v3 with dashboard-style grouping ----------
web_server:
  port: 80
  version: 3
  local: true                 # serve UI assets from device (offline friendly)
  include_internal: false     # hide any entity marked "internal: true"
  sorting_groups:
    - id: grp_relays
      name: "Relays"
      sorting_weight: 10
    - id: grp_rf_controls
      name: "RF Controls"
      sorting_weight: 20
    - id: grp_rf_settings
      name: "RF Settings"
      sorting_weight: 30
    - id: grp_rf_status
      name: "RF Status"
      sorting_weight: 40
    - id: grp_analog
      name: "Analog"
      sorting_weight: 50
    - id: grp_inputs
      name: "Inputs"
      sorting_weight: 60
    - id: grp_advanced
      name: "Advanced"
      sorting_weight: 90

dashboard_import:
  package_import_url: github://hzkincony/kc868-a8/kc868-a8.yaml@main

ota:
  - platform: esphome
    password: "bobthebuilder"

# ---------------- I2C / Ethernet ----------------
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT
  phy_addr: 0

# ---------------- 433 MHz RF (RX=GPIO15, TX=GPIO2) ----------------
remote_receiver:
  pin:
    number: GPIO15
    mode: INPUT_PULLDOWN
  dump:
    - rc_switch
    - raw
  tolerance: 75%
  filter: 100us
  idle: 8ms

  # Learn rc_switch when in learning mode + Protocol=Auto
  on_rc_switch:
    then:
      - if:
          condition:
            lambda: |-
              return id(is_learning) && id(rf_protocol_select).state == "Auto (rc_switch)";
          then:
            - lambda: |-
                id(learned_code) = x.code;
                uint8_t bits = 64 - __builtin_clzll(x.code);
                if (bits == 0) bits = id(learned_bits);
                id(learned_bits) = bits;
                std::string s; s.reserve(bits);
                for (int i = bits - 1; i >= 0; --i)
                  s.push_back((x.code & (1ULL << i)) ? '1' : '0');
                id(learned_bin) = s;
                id(learned_type) = std::string("rc_switch");
                ESP_LOGI("rf", "Learned rc_switch: code=%llu bits=%u",
                         (unsigned long long) id(learned_code), id(learned_bits));
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

      # Runtime match (not learning) → pulse Relay2 for 10s
      - if:
          condition:
            lambda: |-
              if (id(is_learning)) return false;

              // Incoming bits and code
              uint8_t bits = 64 - __builtin_clzll(x.code);
              ESP_LOGD("rf", "rc_switch rx: code=%llu bits=%u",
                       (unsigned long long) x.code, bits);

              // Match helper: bits==0 in a slot = wildcard
              auto match = [&](uint64_t c, uint8_t b){
                if (c == 0) return false;
                if (c != x.code) return false;
                if (b == 0) return true;     // wildcard bit-length
                return b == bits;
              };

              // Check all 16 slots
              if (match(id(slot1_code),  id(slot1_bits)))  return true;
              if (match(id(slot2_code),  id(slot2_bits)))  return true;
              if (match(id(slot3_code),  id(slot3_bits)))  return true;
              if (match(id(slot4_code),  id(slot4_bits)))  return true;
              if (match(id(slot5_code),  id(slot5_bits)))  return true;
              if (match(id(slot6_code),  id(slot6_bits)))  return true;
              if (match(id(slot7_code),  id(slot7_bits)))  return true;
              if (match(id(slot8_code),  id(slot8_bits)))  return true;
              if (match(id(slot9_code),  id(slot9_bits)))  return true;
              if (match(id(slot10_code), id(slot10_bits))) return true;
              if (match(id(slot11_code), id(slot11_bits))) return true;
              if (match(id(slot12_code), id(slot12_bits))) return true;
              if (match(id(slot13_code), id(slot13_bits))) return true;
              if (match(id(slot14_code), id(slot14_bits))) return true;
              if (match(id(slot15_code), id(slot15_bits))) return true;
              if (match(id(slot16_code), id(slot16_bits))) return true;

              ESP_LOGD("rf", "rc_switch no slot matched.");
              return false;
          then:
            - logger.log: "Matched stored keyfob → Relay2 pulse (10s)"
            - switch.turn_on: relay2
            - delay: 10s
            - switch.turn_off: relay2

  # Learn RAW when in learning mode + Protocol=Raw
  on_raw:
    then:
      - if:
          condition:
            lambda: |-
              if (!id(is_learning)) return false;
              if (id(rf_protocol_select).state != "Raw") return false;
              return true;
          then:
            - lambda: |-
                id(learned_raw).clear();
                id(learned_raw).reserve(x.size());
                for (auto v : x) { id(learned_raw).push_back(v); }
                id(learned_type) = std::string("raw");
                ESP_LOGI("rf", "Learned RAW timings: count=%u", (unsigned) id(learned_raw).size());
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

remote_transmitter:
  pin: GPIO2
  carrier_duty_percent: 100%

# ---------------- Globals (incl. 16 slots) ----------------
globals:
  - { id: is_learning,      type: bool,                 restore_value: false, initial_value: 'false' }
  - { id: learned_type,     type: std::string,          restore_value: true,  initial_value: '"none"' }
  - { id: learned_code,     type: uint64_t,             restore_value: true,  initial_value: '0' }
  - { id: learned_bits,     type: uint8_t,              restore_value: true,  initial_value: '24' }
  - { id: learned_bin,      type: std::string,          restore_value: true,  initial_value: '""' }
  - { id: learned_raw,      type: std::vector<int32_t>, restore_value: false, initial_value: 'std::vector<int32_t>()' }
  - { id: last_a1_logged,   type: float,                restore_value: false, initial_value: 'NAN' }
  - { id: last_a2_logged,   type: float,                restore_value: false, initial_value: 'NAN' }

  - { id: slot1_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot2_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot3_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot4_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot5_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot6_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot7_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot8_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot9_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot10_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot11_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot12_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot13_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot14_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot15_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot16_code, type: uint64_t, restore_value: true, initial_value: '0' }

  - { id: slot1_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot2_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot3_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot4_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot5_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot6_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot7_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot8_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot9_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot10_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot11_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot12_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot13_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot14_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot15_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot16_bits, type: uint8_t, restore_value: true, initial_value: '0' }

# ---------------- UI controls (selects, numbers, status) ----------------
select:
  - platform: template
    id: rf_protocol_select
    name: "RF Protocol"
    optimistic: true
    options:
      - "Auto (rc_switch)"
      - "Protocol 1"
      - "Protocol 2"
      - "Protocol 3"
      - "Protocol 4"
      - "Protocol 5"
      - "Protocol 6"
      - "Raw"
    initial_option: "Auto (rc_switch)"
    web_server:
      sorting_group_id: grp_rf_settings
      sorting_weight: 40

number:
  - platform: template
    id: rf_repeat
    name: "RF Repeat"
    min_value: 1
    max_value: 30
    step: 1
    optimistic: true
    initial_value: 10
    web_server:
      sorting_group_id: grp_rf_settings
      sorting_weight: 20

  - platform: template
    id: rf_pulse_len
    name: "RF Pulse (µs)"
    min_value: 200
    max_value: 600
    step: 10
    optimistic: true
    initial_value: 350
    web_server:
      sorting_group_id: grp_rf_settings
      sorting_weight: 30

  - platform: template
    id: slot_select
    name: "RF Slot"
    min_value: 1
    max_value: 16
    step: 1
    optimistic: true
    initial_value: 1
    web_server:
      sorting_group_id: grp_rf_settings
      sorting_weight: 10

text_sensor:
  - platform: template
    id: learned_status
    name: "Learned Status"
    update_interval: 2s
    lambda: |-
      if (id(learned_type) == "rc_switch" && id(learned_bin).size() > 0) {
        char buf[64];
        snprintf(buf, sizeof(buf), "rc_switch: bits=%u code=%llu",
                 id(learned_bits), (unsigned long long) id(learned_code));
        return std::string(buf);
      } else if (id(learned_type) == "raw" && !id(learned_raw).empty()) {
        char buf[64];
        snprintf(buf, sizeof(buf), "raw: %u timings", (unsigned) id(learned_raw).size());
        return std::string(buf);
      }
      return std::string("none");
    web_server:
      sorting_group_id: grp_rf_status
      sorting_weight: 10

# ---------------- PCF8574 expanders ----------------
pcf8574:
  - id: pcf8574_hub_out_1
    address: 0x24
  - id: pcf8574_hub_in_1
    address: 0x22

# ---------------- Relays ----------------

switch:
  - platform: gpio
    id: relay1
    name: "Bookshelf Unlocked"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 0
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 10

  - platform: gpio
    id: relay2
    name: "RF Relay"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 1
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 20

  - platform: gpio
    id: relay3
    name: "Relay 3"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 2
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 30

  - platform: gpio
    id: relay4
    name: "Relay 4"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 3
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 40

  - platform: gpio
    id: relay5
    name: "Relay 5"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 4
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 50

  - platform: gpio
    id: relay6
    name: "Relay 6"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 5
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 60

  - platform: gpio
    id: relay7
    name: "Relay 7"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 6
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 70

  - platform: gpio
    id: relay8
    name: "Relay 8 (learning indicator)"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 7
      inverted: true
    web_server:
      sorting_group_id: grp_relays
      sorting_weight: 80

    - platform: template
    id: log_pause
    name: "Pause Logs"
    restore_state: false
    optimistic: true
    on_turn_on:
      - logger.set_level: WARN     # Pause most logs (INFO/DEBUG suppressed)
      - logger.log: "Logging paused (level=WARN)"
    on_turn_off:
      - logger.set_level: DEBUG    # Resume verbose logs
      - logger.log: "Logging resumed (level=DEBUG)"
    web_server:
      sorting_group_id: grp_advanced
      sorting_weight: 20

# ---------------- ADC with threshold + change-only logging ----------------
sensor:
  - platform: adc
    id: a1_volts
    name: "A1 Voltage"
    pin: GPIO34
    attenuation: 12db
    update_interval: 300ms
    filters:
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a1_logged)) || fabsf(x - id(last_a1_logged)) >= eps) {
              id(last_a1_logged) = x;
              ESP_LOGI("a1", "A1 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - if:
              condition:
                not:
                  switch.is_on: relay1
              then:
                - switch.turn_on: relay1
      - below: 1.95
        then:
          - if:
              condition:
                switch.is_on: relay1
              then:
                - switch.turn_off: relay1
    web_server:
      sorting_group_id: grp_analog
      sorting_weight: 10

  - platform: adc
    id: a2_volts
    name: "A2 Voltage"
    pin: GPIO35
    attenuation: 12db
    update_interval: 300ms
    filters:
      - throttle: 1s
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a2_logged)) || fabsf(x - id(last_a2_logged)) >= eps) {
              id(last_a2_logged) = x;
              ESP_LOGI("a2", "A2 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - script.execute: send_learned_rf
    web_server:
      sorting_group_id: grp_analog
      sorting_weight: 20

# ---------------- Digital inputs ----------------
binary_sensor:
  - platform: gpio
    id: input1
    name: "Input 1 (learn RF)"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 0
      inverted: true
    filters:
      - delayed_on_off: 20ms
    on_press:
      - script.execute: start_learning
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 10

  - platform: gpio
    id: input2
    name: "Input 2"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 1
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 20

  - platform: gpio
    id: input3
    name: "Input 3"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 2
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 30

  - platform: gpio
    id: input4
    name: "Input 4"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 3
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 40

  - platform: gpio
    id: input5
    name: "Input 5"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 4
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 50

  - platform: gpio
    id: input6
    name: "Input 6"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 5
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 60

  - platform: gpio
    id: input7
    name: "Input 7"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 6
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 70

  - platform: gpio
    id: input8
    name: "Input 8"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 7
      inverted: true
    filters:
      - delayed_on_off: 20ms
    web_server:
      sorting_group_id: grp_inputs
      sorting_weight: 80

# ---------------- Buttons -> scripts ----------------
button:
  - platform: template
    id: start_rf_learning_ui
    name: "Start RF Learning"
    on_press:
      - script.execute: start_learning
    web_server:
      sorting_group_id: grp_rf_controls
      sorting_weight: 10

  - platform: template
    id: transmit_learned_433
    name: "Transmit Learned"
    on_press:
      - script.execute: send_learned_rf
    web_server:
      sorting_group_id: grp_rf_controls
      sorting_weight: 20

  - platform: template
    id: learn_to_selected_slot
    name: "Learn → Save Slot"
    on_press:
      - script.execute: start_learning
      - delay: 15s
      - script.execute: save_learned_to_slot
    web_server:
      sorting_group_id: grp_rf_controls
      sorting_weight: 30

  - platform: template
    id: transmit_slot
    name: "Transmit Slot"
    on_press:
      - script.execute: tx_slot_script
    web_server:
      sorting_group_id: grp_rf_controls
      sorting_weight: 40

  - platform: template
    id: clear_slot
    name: "Clear Slot"
    on_press:
      - script.execute: clear_slot_script
    web_server:
      sorting_group_id: grp_rf_controls
      sorting_weight: 50

  # Visible: dump all slots to logs (Advanced card)
  - platform: template
    id: dump_slots
    name: "Dump RF Slots"
    on_press:
      - lambda: |-
          auto dump = [&](int idx, uint64_t c, uint8_t b){
            ESP_LOGI("rf", "Slot %02d: code=%llu bits=%u",
                     idx, (unsigned long long)c, (unsigned)b);
          };
          dump( 1, id(slot1_code),  id(slot1_bits));
          dump( 2, id(slot2_code),  id(slot2_bits));
          dump( 3, id(slot3_code),  id(slot3_bits));
          dump( 4, id(slot4_code),  id(slot4_bits));
          dump( 5, id(slot5_code),  id(slot5_bits));
          dump( 6, id(slot6_code),  id(slot6_bits));
          dump( 7, id(slot7_code),  id(slot7_bits));
          dump( 8, id(slot8_code),  id(slot8_bits));
          dump( 9, id(slot9_code),  id(slot9_bits));
          dump(10, id(slot10_code), id(slot10_bits));
          dump(11, id(slot11_code), id(slot11_bits));
          dump(12, id(slot12_code), id(slot12_bits));
          dump(13, id(slot13_code), id(slot13_bits));
          dump(14, id(slot14_code), id(slot14_bits));
          dump(15, id(slot15_code), id(slot15_bits));
          dump(16, id(slot16_code), id(slot16_bits));
    web_server:
      sorting_group_id: grp_advanced
      sorting_weight: 10

  # Hidden debug helper
  - platform: template
    id: log_learned_values
    name: "Log learned values"
    internal: true
    on_press:
      - lambda: |-
          ESP_LOGI("rf", "Type=%s code=%llu bits=%u raw_count=%u",
            id(learned_type).c_str(), (unsigned long long) id(learned_code),
            id(learned_bits), (unsigned) id(learned_raw).size());

# ---------------- Scripts ----------------
script:
  - id: start_learning
    mode: restart
    then:
      - lambda: 'id(is_learning) = true;'
      - switch.turn_on: relay8
      - lambda: |-
          ESP_LOGI("rf", "Learning mode: %s (15s)", id(rf_protocol_select).state.c_str());
      - delay: 15s
      - if:
          condition:
            lambda: 'return id(is_learning);'
          then:
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8
            - lambda: 'ESP_LOGW("rf", "Learning timed out.");'

  - id: send_learned_rf
    mode: queued
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Raw";'
          then:
            - if:
                condition:
                  lambda: 'return !id(learned_raw).empty();'
                then:
                  - remote_transmitter.transmit_raw:
                      code: !lambda 'return id(learned_raw);'
                      repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
                else:
                  - logger.log: "No RAW timing learned."
          else:
            - if:
                condition:
                  lambda: 'return id(learned_bin).size() > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
                      then:
                        - script.execute: send_rc_switch_300
                      else:
                        - if:
                            condition:
                              lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                            then:
                              - script.execute: send_rc_switch_350
                            else:
                              - script.execute: send_rc_switch_433
                else:
                  - logger.log: "No rc_switch code learned."

  - id: save_learned_to_slot
    mode: queued
    then:
      - lambda: |-
          if (id(learned_type) != "rc_switch" || id(learned_bin).size() == 0) {
            ESP_LOGW("rf", "Save aborted: learned type is not rc_switch.");
            return;
          }
          const int s = (int) id(slot_select).state;
          const uint64_t code = id(learned_code);
          const uint8_t  bits = id(learned_bits);
          switch (s) {
            case 1:  id(slot1_code)=code;  id(slot1_bits)=bits;  break;
            case 2:  id(slot2_code)=code;  id(slot2_bits)=bits;  break;
            case 3:  id(slot3_code)=code;  id(slot3_bits)=bits;  break;
            case 4:  id(slot4_code)=code;  id(slot4_bits)=bits;  break;
            case 5:  id(slot5_code)=code;  id(slot5_bits)=bits;  break;
            case 6:  id(slot6_code)=code;  id(slot6_bits)=bits;  break;
            case 7:  id(slot7_code)=code;  id(slot7_bits)=bits;  break;
            case 8:  id(slot8_code)=code;  id(slot8_bits)=bits;  break;
            case 9:  id(slot9_code)=code;  id(slot9_bits)=bits;  break;
            case 10: id(slot10_code)=code; id(slot10_bits)=bits; break;
            case 11: id(slot11_code)=code; id(slot11_bits)=bits; break;
            case 12: id(slot12_code)=code; id(slot12_bits)=bits; break;
            case 13: id(slot13_code)=code; id(slot13_bits)=bits; break;
            case 14: id(slot14_code)=code; id(slot14_bits)=bits; break;
            case 15: id(slot15_code)=code; id(slot15_bits)=bits; break;
            case 16: id(slot16_code)=code; id(slot16_bits)=bits; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Saved rc_switch to slot %d: bits=%u code=%llu",
                   s, bits, (unsigned long long) code);
      - delay: 6s
      - logger.log: "Saved to flash."

  - id: clear_slot_script
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          switch (s) {
            case 1:  id(slot1_code)=0;  id(slot1_bits)=0;  break;
            case 2:  id(slot2_code)=0;  id(slot2_bits)=0;  break;
            case 3:  id(slot3_code)=0;  id(slot3_bits)=0;  break;
            case 4:  id(slot4_code)=0;  id(slot4_bits)=0;  break;
            case 5:  id(slot5_code)=0;  id(slot5_bits)=0;  break;
            case 6:  id(slot6_code)=0;  id(slot6_bits)=0;  break;
            case 7:  id(slot7_code)=0;  id(slot7_bits)=0;  break;
            case 8:  id(slot8_code)=0;  id(slot8_bits)=0;  break;
            case 9:  id(slot9_code)=0;  id(slot9_bits)=0;  break;
            case 10: id(slot10_code)=0; id(slot10_bits)=0; break;
            case 11: id(slot11_code)=0; id(slot11_bits)=0; break;
            case 12: id(slot12_code)=0; id(slot12_bits)=0; break;
            case 13: id(slot13_code)=0; id(slot13_bits)=0; break;
            case 14: id(slot14_code)=0; id(slot14_bits)=0; break;
            case 15: id(slot15_code)=0; id(slot15_bits)=0; break;
            case 16: id(slot16_code)=0; id(slot16_bits)=0; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Cleared slot %d", s);
      - delay: 6s
      - logger.log: "Cleared from flash."

  - id: tx_slot_script
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          uint64_t code = 0; uint8_t bits = 0;
          switch (s) {
            case 1:  code=id(slot1_code);  bits=id(slot1_bits);  break;
            case 2:  code=id(slot2_code);  bits=id(slot2_bits);  break;
            case 3:  code=id(slot3_code);  bits=id(slot3_bits);  break;
            case 4:  code=id(slot4_code);  bits=id(slot4_bits);  break;
            case 5:  code=id(slot5_code);  bits=id(slot5_bits);  break;
            case 6:  code=id(slot6_code);  bits=id(slot6_bits);  break;
            case 7:  code=id(slot7_code);  bits=id(slot7_bits);  break;
            case 8:  code=id(slot8_code);  bits=id(slot8_bits);  break;
            case 9:  code=id(slot9_code);  bits=id(slot9_bits);  break;
            case 10: code=id(slot10_code); bits=id(slot10_bits); break;
            case 11: code=id(slot11_code); bits=id(slot11_bits); break;
            case 12: code=id(slot12_code); bits=id(slot12_bits); break;
            case 13: code=id(slot13_code); bits=id(slot13_bits); break;
            case 14: code=id(slot14_code); bits=id(slot14_bits); break;
            case 15: code=id(slot15_code); bits=id(slot15_bits); break;
            case 16: code=id(slot16_code); bits=id(slot16_bits); break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          if (code == 0 || bits == 0) {
            ESP_LOGW("rf", "Slot %d empty", s);
            return;
          }
          std::string bin; bin.reserve(bits);
          for (int i = bits - 1; i >= 0; --i)
            bin.push_back((code & (1ULL << i)) ? '1' : '0');
          id(learned_bin) = bin;
      - if:
          condition:
            lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
          then:
            - script.execute: send_rc_switch_300
          else:
            - if:
                condition:
                  lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                then:
                  - script.execute: send_rc_switch_350
                else:
                  - script.execute: send_rc_switch_433

  # --- protocol helpers ---
  - id: send_rc_switch_300
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,10], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [30,71], zero: [4,11], one: [9,6] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,6], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [6,14], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,23], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

  - id: send_rc_switch_350
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,10], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [30,71], zero: [4,11], one: [9,6] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,6], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [6,14], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,23], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

  - id: send_rc_switch_433
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,10], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [30,71], zero: [4,11], one: [9,6] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,6], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [6,14], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,23], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'


      # --- Pause/Resume logging (UI toggle) ---
      


# ---------------- Logging / API ----------------
logger:
  level: DEBUG

api:
