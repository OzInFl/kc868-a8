substitutions:
  name: kc868-a8

esphome:
  name: ${name}
  name_add_mac_suffix: true
  project:
    name: kincony.kc868-a8
    version: "1"

esp32:
  board: esp32dev
  framework:
    type: arduino

web_server:
  port: 80

dashboard_import:
  package_import_url: github://hzkincony/kc868-a8/kc868-a8.yaml@main

ota:
  - platform: esphome
    password: "bobthebuilder"

# I2C
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

# Ethernet (new 'clk' style)
ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT
  phy_addr: 0

# ---------- 433 MHz RF ----------
remote_receiver:
  pin: GPIO2         # KC868-A8 RX (strap pin warning is expected)
  dump:
    - rc_switch
    - raw
  tolerance: 50%
  filter: 250us
  idle: 4ms
  # 1) Normal RC-Switch learn (when protocol select = Auto)
  on_rc_switch:
    then:
      - if:
          condition:
            lambda: |-
              return id(is_learning) && id(rf_protocol_select).state == "Auto (rc_switch)";
          then:
            - lambda: |-
                // Save numeric code & infer bits
                id(learned_code) = x.code;
                uint8_t bits = 64 - __builtin_clzll(x.code);
                if (bits == 0) bits = id(learned_bits);
                id(learned_bits) = bits;
                // Build bitstring (preserve leading zeros)
                std::string s; s.reserve(bits);
                for (int i = bits - 1; i >= 0; --i) s.push_back((x.code & (1ULL << i)) ? '1' : '0');
                id(learned_bin) = s;
                id(learned_type) = std::string("rc_switch");
                ESP_LOGI("rf", "Learned rc_switch: code=%llu bits=%u", id(learned_code), id(learned_bits));
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

  # 2) Raw learn (when protocol select = Raw)
  on_raw:
    then:
      - if:
          condition:
            lambda: |-
              return id(is_learning) && id(rf_protocol_select).state == "Raw";
          then:
            - lambda: |-
                // Save raw timings
                id(learned_raw).clear();
                id(learned_raw).reserve(x.size());
                for (auto v : x) id(learned_raw).push_back(v);
                id(learned_type) = std::string("raw");
                ESP_LOGI("rf", "Learned RAW timings: count=%u", (unsigned) id(learned_raw).size());
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

remote_transmitter:
  pin: GPIO15        # KC868-A8 TX (strap pin warning is expected)
  carrier_duty_percent: 100%

# Persist / runtime storage for learning
globals:
  - id: is_learning
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: learned_type
    type: std::string
    restore_value: yes
    initial_value: '"none"'

  - id: learned_code
    type: uint64_t
    restore_value: yes
    initial_value: '0'

  - id: learned_bits
    type: uint8_t
    restore_value: yes
    initial_value: '24'

  - id: learned_bin
    type: std::string
    restore_value: yes
    initial_value: '""'

  - id: learned_raw
    type: std::vector<int32_t>
    restore_value: no
    initial_value: '{}'

# ---------- UI controls for protocol / pulse / actions ----------
select:
  - platform: template
    id: rf_protocol_select
    name: "RF Protocol"
    optimistic: true
    options:
      - "Auto (rc_switch)"
      - "Protocol 1"
      - "Protocol 2"
      - "Protocol 3"
      - "Protocol 4"
      - "Protocol 5"
      - "Protocol 6"
      - "Raw"
    initial_option: "Auto (rc_switch)"

number:
  - platform: template
    id: rf_pulse_length
    name: "RF Pulse Length (us)"
    min_value: 50
    max_value: 2000
    step: 10
    optimistic: true
    restore_value: true
    initial_value: 350

  - platform: template
    id: rf_repeat
    name: "RF Repeat"
    min_value: 1
    max_value: 20
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 10

# Human-readable status of what we learned
text_sensor:
  - platform: template
    id: learned_status
    name: "RF Learned Status"
    update_interval: 2s
    lambda: |-
      if (id(learned_type) == "rc_switch" && id(learned_bin).size() > 0) {
        char buf[64];
        snprintf(buf, sizeof(buf), "rc_switch: bits=%u code=%llu",
                 id(learned_bits), (unsigned long long) id(learned_code));
        return std::string(buf);
      } else if (id(learned_type) == "raw" && !id(learned_raw).empty()) {
        char buf[64];
        snprintf(buf, sizeof(buf), "raw: %u timings", (unsigned) id(learned_raw).size());
        return std::string(buf);
      }
      return std::string("none");

# ---------- PCF8574 expanders ----------
pcf8574:
  - id: pcf8574_hub_out_1   # outputs 1–8
    address: 0x24
  - id: pcf8574_hub_in_1    # inputs 1–8
    address: 0x22

# ---------- Relays (active-low) ----------
switch:
  - platform: gpio
    id: relay1
    name: "relay1"
    pin: { pcf8574: pcf8574_hub_out_1, number: 0, inverted: true }

  - platform: gpio
    id: relay2
    name: "relay2"
    pin: { pcf8574: pcf8574_hub_out_1, number: 1, inverted: true }

  - platform: gpio
    id: relay3
    name: "relay3"
    pin: { pcf8574: pcf8574_hub_out_1, number: 2, inverted: true }

  - platform: gpio
    id: relay4
    name: "relay4"
    pin: { pcf8574: pcf8574_hub_out_1, number: 3, inverted: true }

  - platform: gpio
    id: relay5
    name: "relay5"
    pin: { pcf8574: pcf8574_hub_out_1, number: 4, inverted: true }

  - platform: gpio
    id: relay6
    name: "relay6"
    pin: { pcf8574: pcf8574_hub_out_1, number: 5, inverted: true }

  - platform: gpio
    id: relay7
    name: "relay7"
    pin: { pcf8574: pcf8574_hub_out_1, number: 6, inverted: true }

  - platform: gpio
    id: relay8
    name: "relay8 (learning indicator)"
    pin: { pcf8574: pcf8574_hub_out_1, number: 7, inverted: true }

# ---------- Analog thresholds ----------
sensor:
  - platform: adc
    id: a1_volts
    name: "A1 Voltage"
    pin: GPIO34
    attenuation: 12db
    update_interval: 300ms
    filters:
      - median: { window_size: 5, send_every: 2, send_first_at: 1 }
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value_range:
      - above: 2.05
        then:
          - if:
              condition: { not: { switch.is_on: relay1 } }
              then:
                - switch.turn_on: relay1
      - below: 1.95
        then:
          - if:
              condition: { switch.is_on: relay1 }
              then:
                - switch.turn_off: relay1

  - platform: adc
    id: a2_volts
    name: "A2 Voltage"
    pin: GPIO35
    attenuation: 12db
    update_interval: 300ms
    filters:
      - throttle: 1s
      - median: { window_size: 5, send_every: 2, send_first_at: 1 }
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value_range:
      - above: 2.05
        then:
          - script.execute: send_learned_rf

# ---------- Digital inputs ----------
binary_sensor:
  # DI1: enter learning mode (Relay8 = indicator, 15 s window)
  - platform: gpio
    id: input1
    name: "input1 (learn RF)"
    pin: { pcf8574: pcf8574_hub_in_1, number: 0, inverted: true }
    filters: [ delayed_on_off: 20ms ]
    on_press:
      - script.execute: start_learning

  - platform: gpio
    id: input2
    name: "input2"
    pin: { pcf8574: pcf8574_hub_in_1, number: 1, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input3
    name: "input3"
    pin: { pcf8574: pcf8574_hub_in_1, number: 2, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input4
    name: "input4"
    pin: { pcf8574: pcf8574_hub_in_1, number: 3, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input5
    name: "input5"
    pin: { pcf8574: pcf8574_hub_in_1, number: 4, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input6
    name: "input6"
    pin: { pcf8574: pcf8574_hub_in_1, number: 5, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input7
    name: "input7"
    pin: { pcf8574: pcf8574_hub_in_1, number: 6, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input8
    name: "input8"
    pin: { pcf8574: pcf8574_hub_in_1, number: 7, inverted: true }
    filters: [ delayed_on_off: 20ms ]

# ---------- Web UI buttons ----------
button:
  - platform: template
    name: "Start RF learning (UI)"
    on_press:
      - script.execute: start_learning

  - platform: template
    name: "Transmit learned 433"
    on_press:
      - script.execute: send_learned_rf

# ---------- Scripts ----------
script:
  # Enter learning window (15 s)
  - id: start_learning
    mode: restart
    then:
      - lambda: 'id(is_learning) = true;'
      - switch.turn_on: relay8
      - logger.log: !lambda |-
          return ("Learning mode: " + id(rf_protocol_select).state + " (15s)").c_str();
      - delay: 15s
      - if:
          condition: 'return id(is_learning);'
          then:
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8
            - logger.log: "Learning timed out."

  # Transmit learned RF according to protocol select
  - id: send_learned_rf
    mode: queued
    then:
      - lambda: |-
          auto opt = id(rf_protocol_select).state;
          if (opt == "Raw") {
            if (!id(learned_raw).empty()) {
              id(logger).log(esphome::LOG_LEVEL_INFO, "TX: RAW timings");
              id(remote_transmitter).transmit_raw(id(learned_raw));
            } else {
              id(logger).log(esphome::LOG_LEVEL_WARN, "No RAW timing learned.");
            }
            return;
          }
          // For rc_switch-style protocols, need a bitstring
          if (id(learned_bin).empty()) {
            id(logger).log(esphome::LOG_LEVEL_WARN, "No rc_switch code learned.");
            return;
          }
          const int pl = (int) id(rf_pulse_length).state;
          const int rep = (int) id(rf_repeat).state;
          // Build protocol timings by option (defaults to Protocol 1 style)
          esphome::remote_base::RCSwitchBase proto;
          if (opt == "Protocol 1" || opt == "Auto (rc_switch)") {
            proto = esphome::remote_base::RCSwitchBase(pl, {1,31}, {1,3}, {3,1});
          } else if (opt == "Protocol 2") {
            proto = esphome::remote_base::RCSwitchBase(pl, {1,10}, {1,2}, {2,1});
          } else if (opt == "Protocol 3") {
            proto = esphome::remote_base::RCSwitchBase(pl, {30,71}, {4,11}, {9,6});
          } else if (opt == "Protocol 4") {
            proto = esphome::remote_base::RCSwitchBase(pl, {1,6}, {1,3}, {3,1});
          } else if (opt == "Protocol 5") {
            proto = esphome::remote_base::RCSwitchBase(pl, {6,14}, {1,2}, {2,1});
          } else if (opt == "Protocol 6") {
            proto = esphome::remote_base::RCSwitchBase(pl, {1,23}, {1,2}, {2,1});
          } else { // fallback
            proto = esphome::remote_base::RCSwitchBase(pl, {1,31}, {1,3}, {3,1});
          }
          for (int i = 0; i < rep; i++) {
            id(remote_transmitter).transmit_rc_switch_raw(id(learned_bin), proto);
          }

# Logging / API
logger:
  id: logger
  level: DEBUG
api:
