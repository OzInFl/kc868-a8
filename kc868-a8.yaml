substitutions:
  name: kc868-a8

esphome:
  name: ${name}
  name_add_mac_suffix: true
  project:
    name: kincony.kc868-a8
    version: "1"
  # Safety: ensure relay2 OFF after boot
  on_boot:
    priority: 600
    then:
      - switch.turn_off: relay2

esp32:
  board: esp32dev
  framework:
    type: arduino

web_server:
  port: 80

dashboard_import:
  package_import_url: github://hzkincony/kc868-a8/kc868-a8.yaml@main

ota:
  - platform: esphome
    password: "bobthebuilder"

# I2C
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

# Ethernet (use new 'clk' style)
ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT
  phy_addr: 0

# ---------- 433 MHz RF (per your working wiring: RX=GPIO15, TX=GPIO2) ----------
remote_receiver:
  pin:
    number: GPIO15        # RECEIVER DATA (you found RX/TX needed reversing)
    mode: INPUT_PULLDOWN
  dump:
    - rc_switch
    - raw
  tolerance: 65%
  filter: 100us
  idle: 8ms

  # Learn rc_switch when in learning + protocol select is Auto
  on_rc_switch:
    then:
      - if:
          condition:
            lambda: 'return id(is_learning) && id(rf_protocol_select).state == "Auto (rc_switch)";'
          then:
            - lambda: |-
                id(learned_code) = x.code;
                uint8_t bits = 64 - __builtin_clzll(x.code);
                if (bits == 0) bits = id(learned_bits);
                id(learned_bits) = bits;
                std::string s; s.reserve(bits);
                for (int i = bits - 1; i >= 0; --i) {
                  s.push_back((x.code & (1ULL << i)) ? '1' : '0');
                }
                id(learned_bin) = s;
                id(learned_type) = std::string("rc_switch");
                ESP_LOGI("rf", "Learned rc_switch: code=%llu bits=%u",
                         (unsigned long long) id(learned_code), id(learned_bits));
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

      # Runtime: if any stored slot matches, pulse Relay2 for 10s
      - if:
          condition:
            lambda: |-
              if (id(is_learning)) return false;
              uint8_t bits = 64 - __builtin_clzll(x.code);
              auto match = [&](uint64_t c, uint8_t b){ return (c!=0 && b==bits && c==x.code); };
              if (match(id(slot1_code), id(slot1_bits))) return true;
              if (match(id(slot2_code), id(slot2_bits))) return true;
              if (match(id(slot3_code), id(slot3_bits))) return true;
              if (match(id(slot4_code), id(slot4_bits))) return true;
              if (match(id(slot5_code), id(slot5_bits))) return true;
              if (match(id(slot6_code), id(slot6_bits))) return true;
              if (match(id(slot7_code), id(slot7_bits))) return true;
              if (match(id(slot8_code), id(slot8_bits))) return true;
              if (match(id(slot9_code), id(slot9_bits))) return true;
              if (match(id(slot10_code), id(slot10_bits))) return true;
              if (match(id(slot11_code), id(slot11_bits))) return true;
              if (match(id(slot12_code), id(slot12_bits))) return true;
              if (match(id(slot13_code), id(slot13_bits))) return true;
              if (match(id(slot14_code), id(slot14_bits))) return true;
              if (match(id(slot15_code), id(slot15_bits))) return true;
              if (match(id(slot16_code), id(slot16_bits))) return true;
              return false;
          then:
            - logger.log: "Matched stored keyfob → Relay2 pulse (10s)"
            - switch.turn_on: relay2
            - delay: 10s
            - switch.turn_off: relay2

  # Learn RAW when in learning + protocol select is Raw
  on_raw:
    then:
      - if:
          condition:
            lambda: 'return id(is_learning) && id(rf_protocol_select).state == "Raw";'
          then:
            - lambda: |-
                id(learned_raw).clear();
                id(learned_raw).reserve(x.size());
                for (auto v : x) { id(learned_raw).push_back(v); }
                id(learned_type) = std::string("raw");
                ESP_LOGI("rf", "Learned RAW timings: count=%u", (unsigned) id(learned_raw).size());
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

remote_transmitter:
  pin: GPIO2             # TRANSMITTER DATA
  carrier_duty_percent: 100%

# ---------- Globals (state, learned, slots, analog last-logged) ----------
globals:
  - id: is_learning
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: learned_type
    type: std::string
    restore_value: yes
    initial_value: '"none"'

  - id: learned_code
    type: uint64_t
    restore_value: yes
    initial_value: '0'

  - id: learned_bits
    type: uint8_t
    restore_value: yes
    initial_value: '24'

  - id: learned_bin
    type: std::string
    restore_value: yes
    initial_value: '""'

  - id: learned_raw
    type: std::vector<int32_t>
    restore_value: no
    initial_value: 'std::vector<int32_t>()'

  # Two helper strings (for slot transmit)
  - id: tmp_bin
    type: std::string
    restore_value: no
    initial_value: '""'

  # Last-logged values for A1/A2 (to reduce log spam)
  - id: last_a1_logged
    type: float
    restore_value: no
    initial_value: 'NAN'
  - id: last_a2_logged
    type: float
    restore_value: no
    initial_value: 'NAN'

  # ----- RF code book: 16 slots (code+bits, persistent) -----
  - id: slot1_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot2_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot3_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot4_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot5_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot6_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot7_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot8_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot9_code   ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot10_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot11_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot12_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot13_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot14_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot15_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'
  - id: slot16_code  ; type: uint64_t ; restore_value: yes ; initial_value: '0'

  - id: slot1_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot2_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot3_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot4_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot5_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot6_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot7_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot8_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot9_bits   ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot10_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot11_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot12_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot13_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot14_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot15_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'
  - id: slot16_bits  ; type: uint8_t  ; restore_value: yes ; initial_value: '0'

# ---------- UI controls ----------
select:
  - platform: template
    id: rf_protocol_select
    name: "RF Protocol"
    optimistic: true
    options:
      - "Auto (rc_switch)"
      - "Protocol 1"
      - "Protocol 2"
      - "Protocol 3"
      - "Protocol 4"
      - "Protocol 5"
      - "Protocol 6"
      - "Raw"
    initial_option: "Auto (rc_switch)"

number:
  - platform: template
    id: rf_repeat
    name: "RF Repeat"
    min_value: 1
    max_value: 30
    step: 1
    optimistic: true
    initial_value: 10

  - platform: template
    id: rf_pulse_len
    name: "RF Pulse Length (µs)"
    min_value: 200
    max_value: 600
    step: 10
    optimistic: true
    initial_value: 350

  - platform: template
    id: slot_select
    name: "RF Slot"
    min_value: 1
    max_value: 16
    step: 1
    optimistic: true
    initial_value: 1

text_sensor:
  - platform: template
    id: learned_status
    name: "RF Learned Status"
    update_interval: 2s
    lambda: |-
      if (id(learned_type) == "rc_switch" && id(learned_bin).size() > 0) {
        char buf[64];
        snprintf(buf, sizeof(buf), "rc_switch: bits=%u code=%llu",
                 id(learned_bits), (unsigned long long) id(learned_code));
        return std::string(buf);
      } else if (id(learned_type) == "raw" && !id(learned_raw).empty()) {
        char buf[64];
        snprintf(buf, sizeof(buf), "raw: %u timings", (unsigned) id(learned_raw).size());
        return std::string(buf);
      }
      return std::string("none");

  # Slot status lines
  - platform: template
    name: "Slot 01"
    update_interval: 3s
    lambda: |-
      if (id(slot1_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot1_bits), (unsigned long long) id(slot1_code));
      return std::string(b);
  - platform: template
    name: "Slot 02"
    update_interval: 3s
    lambda: |-
      if (id(slot2_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot2_bits), (unsigned long long) id(slot2_code));
      return std::string(b);
  - platform: template
    name: "Slot 03"
    update_interval: 3s
    lambda: |-
      if (id(slot3_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot3_bits), (unsigned long long) id(slot3_code));
      return std::string(b);
  - platform: template
    name: "Slot 04"
    update_interval: 3s
    lambda: |-
      if (id(slot4_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot4_bits), (unsigned long long) id(slot4_code));
      return std::string(b);
  - platform: template
    name: "Slot 05"
    update_interval: 3s
    lambda: |-
      if (id(slot5_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot5_bits), (unsigned long long) id(slot5_code));
      return std::string(b);
  - platform: template
    name: "Slot 06"
    update_interval: 3s
    lambda: |-
      if (id(slot6_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot6_bits), (unsigned long long) id(slot6_code));
      return std::string(b);
  - platform: template
    name: "Slot 07"
    update_interval: 3s
    lambda: |-
      if (id(slot7_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot7_bits), (unsigned long long) id(slot7_code));
      return std::string(b);
  - platform: template
    name: "Slot 08"
    update_interval: 3s
    lambda: |-
      if (id(slot8_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot8_bits), (unsigned long long) id(slot8_code));
      return std::string(b);
  - platform: template
    name: "Slot 09"
    update_interval: 3s
    lambda: |-
      if (id(slot9_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot9_bits), (unsigned long long) id(slot9_code));
      return std::string(b);
  - platform: template
    name: "Slot 10"
    update_interval: 3s
    lambda: |-
      if (id(slot10_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot10_bits), (unsigned long long) id(slot10_code));
      return std::string(b);
  - platform: template
    name: "Slot 11"
    update_interval: 3s
    lambda: |-
      if (id(slot11_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot11_bits), (unsigned long long) id(slot11_code));
      return std::string(b);
  - platform: template
    name: "Slot 12"
    update_interval: 3s
    lambda: |-
      if (id(slot12_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot12_bits), (unsigned long long) id(slot12_code));
      return std::string(b);
  - platform: template
    name: "Slot 13"
    update_interval: 3s
    lambda: |-
      if (id(slot13_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot13_bits), (unsigned long long) id(slot13_code));
      return std::string(b);
  - platform: template
    name: "Slot 14"
    update_interval: 3s
    lambda: |-
      if (id(slot14_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot14_bits), (unsigned long long) id(slot14_code));
      return std::string(b);
  - platform: template
    name: "Slot 15"
    update_interval: 3s
    lambda: |-
      if (id(slot15_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot15_bits), (unsigned long long) id(slot15_code));
      return std::string(b);
  - platform: template
    name: "Slot 16"
    update_interval: 3s
    lambda: |-
      if (id(slot16_code) == 0) return std::string("Empty");
      char b[64]; snprintf(b, sizeof(b), "bits=%u code=%llu", id(slot16_bits), (unsigned long long) id(slot16_code));
      return std::string(b);

# ---------- PCF8574 expanders ----------
pcf8574:
  - id: pcf8574_hub_out_1
    address: 0x24
  - id: pcf8574_hub_in_1
    address: 0x22

# ---------- Relays ----------
switch:
  - platform: gpio
    id: relay1
    name: "relay1"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 0
      inverted: true

  - platform: gpio
    id: relay2
    name: "relay2"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 1
      inverted: true

  - platform: gpio
    id: relay3
    name: "relay3"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 2
      inverted: true

  - platform: gpio
    id: relay4
    name: "relay4"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 3
      inverted: true

  - platform: gpio
    id: relay5
    name: "relay5"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 4
      inverted: true

  - platform: gpio
    id: relay6
    name: "relay6"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 5
      inverted: true

  - platform: gpio
    id: relay7
    name: "relay7"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 6
      inverted: true

  - platform: gpio
    id: relay8
    name: "relay8 (learning indicator)"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 7
      inverted: true

# ---------- Analog inputs with thresholds + change-only logging ----------
sensor:
  - platform: adc
    id: a1_volts
    name: "A1 Voltage"
    pin: GPIO34
    attenuation: 12db
    update_interval: 300ms
    filters:
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a1_logged)) || fabsf(x - id(last_a1_logged)) >= eps) {
              id(last_a1_logged) = x;
              ESP_LOGI("a1", "A1 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - if:
              condition:
                not:
                  switch.is_on: relay1
              then:
                - switch.turn_on: relay1
      - below: 1.95
        then:
          - if:
              condition:
                switch.is_on: relay1
              then:
                - switch.turn_off: relay1

  - platform: adc
    id: a2_volts
    name: "A2 Voltage"
    pin: GPIO35
    attenuation: 12db
    update_interval: 300ms
    filters:
      - throttle: 1s
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a2_logged)) || fabsf(x - id(last_a2_logged)) >= eps) {
              id(last_a2_logged) = x;
              ESP_LOGI("a2", "A2 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - script.execute: send_learned_rf

# ---------- Digital inputs ----------
binary_sensor:
  - platform: gpio
    id: input1
    name: "input1 (learn RF)"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 0
    inverted: true
    filters:
      - delayed_on_off: 20ms
    on_press:
      - script.execute: start_learning

  - platform: gpio
    id: input2
    name: "input2"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 1
    inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input3
    name: "input3"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 2
    inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input4
    name: "input4"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 3
    inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input5
    name: "input5"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 4
    inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input6
    name: "input6"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 5
    inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input7
    name: "input7"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 6
    inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input8
    name: "input8"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 7
    inverted: true
    filters:
      - delayed_on_off: 20ms

# ---------- Web UI buttons ----------
button:
  - platform: template
    name: "Start RF learning (UI)"
    on_press:
      - script.execute: start_learning

  - platform: template
    name: "Transmit learned 433"
    on_press:
      - script.execute: send_learned_rf

  - platform: template
    name: "Save learned → slot"
    on_press:
      - script.execute: save_learned_to_slot

  - platform: template
    name: "Transmit slot"
    on_press:
      - script.execute: transmit_slot

  - platform: template
    name: "Clear slot"
    on_press:
      - script.execute: clear_slot

  - platform: template
    name: "Learn to selected slot"
    on_press:
      - script.execute: start_learning
      - delay: 15s
      - script.execute: save_learned_to_slot

  - platform: template
    name: "Log learned values"
    on_press:
      - lambda: |-
          ESP_LOGI("rf", "Type=%s code=%llu bits=%u raw_count=%u",
            id(learned_type).c_str(), (unsigned long long) id(learned_code),
            id(learned_bits), (unsigned) id(learned_raw).size());

# ---------- Scripts ----------
script:
  # Enter 15s learning window (Relay8 indicator)
  - id: start_learning
    mode: restart
    then:
      - lambda: 'id(is_learning) = true;'
      - switch.turn_on: relay8
      - lambda: |-
          ESP_LOGI("rf", "Learning mode: %s (15s)", id(rf_protocol_select).state.c_str());
      - delay: 15s
      - if:
          condition:
            lambda: 'return id(is_learning);'
          then:
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8
            - lambda: 'ESP_LOGW("rf", "Learning timed out.");'

  # Send learned RF (RAW or rc_switch via 300/350/433 blocks)
  - id: send_learned_rf
    mode: queued
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Raw";'
          then:
            - if:
                condition:
                  lambda: 'return !id(learned_raw).empty();'
                then:
                  - remote_transmitter.transmit_raw:
                      code: !lambda 'return id(learned_raw);'
                      repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
                else:
                  - logger.log: "No RAW timing learned."
          else:
            - if:
                condition:
                  lambda: 'return id(learned_bin).size() > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
                      then:
                        - script.execute: send_rc_switch_300
                      else:
                        - if:
                            condition:
                              lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                            then:
                              - script.execute: send_rc_switch_350
                            else:
                              - script.execute: send_rc_switch_433
                else:
                  - logger.log: "No rc_switch code learned."

  # Save learned rc_switch → selected slot
  - id: save_learned_to_slot
    mode: queued
    then:
      - lambda: |-
          if (id(learned_type) != "rc_switch" || id(learned_bin).size() == 0) {
            ESP_LOGW("rf", "Save aborted: learned type is not rc_switch.");
            return;
          }
          const int s = (int) id(slot_select).state;
          const uint64_t code = id(learned_code);
          const uint8_t  bits = id(learned_bits);
          switch (s) {
            case 1:  id(slot1_code)=code;  id(slot1_bits)=bits;  break;
            case 2:  id(slot2_code)=code;  id(slot2_bits)=bits;  break;
            case 3:  id(slot3_code)=code;  id(slot3_bits)=bits;  break;
            case 4:  id(slot4_code)=code;  id(slot4_bits)=bits;  break;
            case 5:  id(slot5_code)=code;  id(slot5_bits)=bits;  break;
            case 6:  id(slot6_code)=code;  id(slot6_bits)=bits;  break;
            case 7:  id(slot7_code)=code;  id(slot7_bits)=bits;  break;
            case 8:  id(slot8_code)=code;  id(slot8_bits)=bits;  break;
            case 9:  id(slot9_code)=code;  id(slot9_bits)=bits;  break;
            case 10: id(slot10_code)=code; id(slot10_bits)=bits; break;
            case 11: id(slot11_code)=code; id(slot11_bits)=bits; break;
            case 12: id(slot12_code)=code; id(slot12_bits)=bits; break;
            case 13: id(slot13_code)=code; id(slot13_bits)=bits; break;
            case 14: id(slot14_code)=code; id(slot14_bits)=bits; break;
            case 15: id(slot15_code)=code; id(slot15_bits)=bits; break;
            case 16: id(slot16_code)=code; id(slot16_bits)=bits; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Saved rc_switch to slot %d: bits=%u code=%llu", s, bits, (unsigned long long) code);

  # Clear selected slot
  - id: clear_slot
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          switch (s) {
            case 1:  id(slot1_code)=0;  id(slot1_bits)=0;  break;
            case 2:  id(slot2_code)=0;  id(slot2_bits)=0;  break;
            case 3:  id(slot3_code)=0;  id(slot3_bits)=0;  break;
            case 4:  id(slot4_code)=0;  id(slot4_bits)=0;  break;
            case 5:  id(slot5_code)=0;  id(slot5_bits)=0;  break;
            case 6:  id(slot6_code)=0;  id(slot6_bits)=0;  break;
            case 7:  id(slot7_code)=0;  id(slot7_bits)=0;  break;
            case 8:  id(slot8_code)=0;  id(slot8_bits)=0;  break;
            case 9:  id(slot9_code)=0;  id(slot9_bits)=0;  break;
            case 10: id(slot10_code)=0; id(slot10_bits)=0; break;
            case 11: id(slot11_code)=0; id(slot11_bits)=0; break;
            case 12: id(slot12_code)=0; id(slot12_bits)=0; break;
            case 13: id(slot13_code)=0; id(slot13_bits)=0; break;
            case 14: id(slot14_code)=0; id(slot14_bits)=0; break;
            case 15: id(slot15_code)=0; id(slot15_bits)=0; break;
            case 16: id(slot16_code)=0; id(slot16_bits)=0; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Cleared slot %d", s);

  # Transmit selected slot (build bin, reuse same 300/350/433 blocks)
  - id: transmit_slot
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          uint64_t code = 0; uint8_t bits = 0;
          switch (s) {
            case 1:  code=id(slot1_code);  bits=id(slot1_bits);  break;
            case 2:  code=id(slot2_code);  bits=id(slot2_bits);  break;
            case 3:  code=id(slot3_code);  bits=id(slot3_bits);  break;
            case 4:  code=id(slot4_code);  bits=id(slot4_bits);  break;
            case 5:  code=id(slot5_code);  bits=id(slot5_bits);  break;
            case 6:  code=id(slot6_code);  bits=id(slot6_bits);  break;
            case 7:  code=id(slot7_code);  bits=id(slot7_bits);  break;
            case 8:  code=id(slot8_code);  bits=id(slot8_bits);  break;
            case 9:  code=id(slot9_code);  bits=id(slot9_bits);  break;
            case 10: code=id(slot10_code); bits=id(slot10_bits); break;
            case 11: code=id(slot11_code); bits=id(slot11_bits); break;
            case 12: code=id(slot12_code); bits=id(slot12_bits); break;
            case 13: code=id(slot13_code); bits=id(slot13_bits); break;
            case 14: code=id(slot14_code); bits=id(slot14_bits); break;
            case 15: code=id(slot15_code); bits=id(slot15_bits); break;
            case 16: code=id(slot16_code); bits=id(slot16_bits); break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          if (code == 0 || bits == 0) {
            ESP_LOGW("rf", "Slot %d empty", s);
            return;
          }
          // Build bitstring into learned_bin (reuse sender scripts)
          std::string bin; bin.reserve(bits);
          for (int i = bits - 1; i >= 0; --i)
            bin.push_back((code & (1ULL << i)) ? '1' : '0');
          id(learned_bin) = bin;

      - if:
          condition:
            lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
          then:
            - script.execute: send_rc_switch_300
          else:
            - if:
                condition:
                  lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                then:
                  - script.execute: send_rc_switch_350
                else:
                  - script.execute: send_rc_switch_433

  # Helper scripts: static protocol blocks (no templating inside 'protocol:')
  - id: send_rc_switch_300
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 300
                  sync: [1, 31]
                  zero: [1, 3]
                  one: [3, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 2";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 300
                  sync: [1, 10]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 3";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 300
                  sync: [30, 71]
                  zero: [4, 11]
                  one: [9, 6]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 4";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 300
                  sync: [1, 6]
                  zero: [1, 3]
                  one: [3, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 5";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 300
                  sync: [6, 14]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 6";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 300
                  sync: [1, 23]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

  - id: send_rc_switch_350
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 350
                  sync: [1, 31]
                  zero: [1, 3]
                  one: [3, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 2";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 350
                  sync: [1, 10]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 3";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 350
                  sync: [30, 71]
                  zero: [4, 11]
                  one: [9, 6]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 4";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 350
                  sync: [1, 6]
                  zero: [1, 3]
                  one: [3, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 5";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 350
                  sync: [6, 14]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 6";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 350
                  sync: [1, 23]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

  - id: send_rc_switch_433
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 433
                  sync: [1, 31]
                  zero: [1, 3]
                  one: [3, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 2";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 433
                  sync: [1, 10]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 3";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 433
                  sync: [30, 71]
                  zero: [4, 11]
                  one: [9, 6]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 4";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 433
                  sync: [1, 6]
                  zero: [1, 3]
                  one: [3, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 5";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 433
                  sync: [6, 14]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Protocol 6";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol:
                  pulse_length: 433
                  sync: [1, 23]
                  zero: [1, 2]
                  one: [2, 1]
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

# Logging / API
logger:
  level: DEBUG
api:
