substitutions:
  name: kc868-a8

esphome:
  name: ${name}
  name_add_mac_suffix: true
  project:
    name: kincony.kc868-a8
    version: "1"
  on_boot:
    priority: 600
    then:
      - switch.turn_off: relay2

esp32:
  board: esp32dev
  framework:
    type: arduino

# Persist preferences more quickly so slot saves survive power loss
preferences:
  flash_write_interval: 5s

# ---------------- Web server: minimal same-origin UI at /ui ----------------
web_server:
  port: 80
  include_internal: true
  routes:
    - uri: /
      method: GET
      handler: !lambda |-
        const char* html =
          "<!doctype html>"
          "<html><head><meta charset='utf-8'>"
          "<meta name='viewport' content='width=device-width,initial-scale=1'>"
          "<title>KC868-A8 UI</title>"
          "<style>"
          "body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0b0f17;color:#e5e7eb;margin:0}"
          "header{padding:12px 16px;border-bottom:1px solid #1f2937}h1{margin:0;font-size:18px}"
          "main{padding:16px}button,input,select{background:#0f172a;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:10px 12px;margin:4px}"
          "</style>"
          "</head><body>"
          "<header><h1>KC868-A8 · Local UI</h1></header>"
          "<main>"
          "<h3>Relays</h3>"
          "<div>"
            "<button onclick=\"new Image().src='/switch/relay1/toggle?_='+Date.now()\">Relay 1 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay2/toggle?_='+Date.now()\">Relay 2 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay3/toggle?_='+Date.now()\">Relay 3 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay4/toggle?_='+Date.now()\">Relay 4 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay5/toggle?_='+Date.now()\">Relay 5 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay6/toggle?_='+Date.now()\">Relay 6 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay7/toggle?_='+Date.now()\">Relay 7 Toggle</button>"
            "<button onclick=\"new Image().src='/switch/relay8/toggle?_='+Date.now()\">Relay 8 Toggle</button>"
          "</div>"
          "<h3>RF</h3>"
          "<div>"
            "<button onclick=\"new Image().src('/button/start_rf_learning_ui/press?_='+Date.now())\">Start Learning</button>"
            "<button onclick=\"new Image().src('/button/transmit_learned_433/press?_='+Date.now())\">Transmit Learned</button>"
            "<button onclick=\"new Image().src('/button/save_learned_slot/press?_='+Date.now())\">Save → Slot</button>"
            "<button onclick=\"new Image().src('/button/transmit_slot/press?_='+Date.now())\">Transmit Slot</button>"
            "<button onclick=\"new Image().src('/button/clear_slot/press?_='+Date.now())\">Clear Slot</button>"
            "<button onclick=\"new Image().src('/button/learn_to_selected_slot/press?_='+Date.now())\">Learn→Save Slot</button>"
          "</div>"
          "<div>"
            "Slot: <input id='slot' type='number' min='1' max='16' value='1' oninput=\"new Image().src('/number/slot_select/set?value='+this.value+'&_='+Date.now())\"> "
            "Repeat: <input id='rep' type='number' min='1' max='30' value='10' oninput=\"new Image().src('/number/rf_repeat/set?value='+this.value+'&_='+Date.now())\"> "
            "Pulse(µs): <input id='pls' type='number' min='200' max='600' step='10' value='350' oninput=\"new Image().src('/number/rf_pulse_len/set?value='+this.value+'&_='+Date.now())\"> "
            "Protocol: <select id='proto' onchange=\"new Image().src('/select/rf_protocol_select/set?option='+encodeURIComponent(this.value)+'&_='+Date.now())\">"
              "<option>Auto (rc_switch)</option><option>Protocol 1</option><option>Protocol 2</option>"
              "<option>Protocol 3</option><option>Protocol 4</option><option>Protocol 5</option>"
              "<option>Protocol 6</option><option>Raw</option>"
            "</select>"
          "</div>"
          "<div>"
            "Min Bits: <input type='range' min='1' max='64' value='20' oninput=\"new Image().src('/number/rf_min_bits/set?value='+this.value+'&_='+Date.now())\"> "
            "Min RAW: <input type='range' min='0' max='200' step='5' value='40' oninput=\"new Image().src('/number/rf_min_raw_timings/set?value='+this.value+'&_='+Date.now())\"> "
            "Quiet(ms): <input type='range' min='0' max='2000' step='50' value='200' oninput=\"new Image().src('/number/rf_quiet_ms/set?value='+this.value+'&_='+Date.now())\"> "
          "</div>"
          "</main></body></html>";
        request->send(200, "text/html; charset=utf-8", html);

    - uri: /ui
      method: GET
      handler: !lambda |-
        // Serve the same UI at /ui for convenience
        const char* html =
          "<!doctype html><html><head><meta charset='utf-8'>"
          "<meta name='viewport' content='width=device-width,initial-scale=1'>"
          "<title>KC868-A8 UI</title></head><body>"
          "<script>location.replace('/');</script>"
          "If you see this, <a href='/'>click here</a>."
          "</body></html>";
        request->send(200, "text/html; charset=utf-8", html);

          return;
        }
        // Let other paths fall through to default handling.

dashboard_import:
  package_import_url: github://hzkincony/kc868-a8/kc868-a8.yaml@main

ota:
  - platform: esphome
    password: "bobthebuilder"

# ---------------- I2C / Ethernet ----------------
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT
  phy_addr: 0

# ---------------- 433 MHz RF (RX=GPIO15, TX=GPIO2) ----------------
remote_receiver:
  pin:
    number: GPIO15
    mode: INPUT_PULLDOWN
  dump:
    - rc_switch
    - raw
  tolerance: 65%
  filter: 100us
  idle: 8ms

  on_rc_switch:
    then:
      # Learn rc_switch (with squelch)
      - if:
          condition:
            lambda: |-
              uint8_t bits = 64 - __builtin_clzll(x.code);
              if (bits < (uint8_t) id(rf_min_bits).state) return false;
              uint32_t now = millis();
              if (now - id(last_rx_ms) < (uint32_t) id(rf_quiet_ms).state) return false;
              id(last_rx_ms) = now;
              return id(is_learning) && id(rf_protocol_select).state == "Auto (rc_switch)";
          then:
            - lambda: |-
                id(learned_code) = x.code;
                uint8_t bits = 64 - __builtin_clzll(x.code);
                if (bits == 0) bits = id(learned_bits);
                id(learned_bits) = bits;
                std::string s; s.reserve(bits);
                for (int i = bits - 1; i >= 0; --i)
                  s.push_back((x.code & (1ULL << i)) ? '1' : '0');
                id(learned_bin) = s;
                id(learned_type) = std::string("rc_switch");
                ESP_LOGI("rf", "Learned rc_switch: code=%llu bits=%u",
                         (unsigned long long) id(learned_code), id(learned_bits));
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

      # Runtime match (not learning) → pulse Relay2 for 10s (with squelch)
      - if:
          condition:
            lambda: |-
              if (id(is_learning)) return false;
              uint8_t bits = 64 - __builtin_clzll(x.code);
              if (bits < (uint8_t) id(rf_min_bits).state) return false;
              uint32_t now = millis();
              if (now - id(last_rx_ms) < (uint32_t) id(rf_quiet_ms).state) return false;
              id(last_rx_ms) = now;
              auto match = [&](uint64_t c, uint8_t b){ return (c!=0 && b==bits && c==x.code); };
              if (match(id(slot1_code), id(slot1_bits))) return true;
              if (match(id(slot2_code), id(slot2_bits))) return true;
              if (match(id(slot3_code), id(slot3_bits))) return true;
              if (match(id(slot4_code), id(slot4_bits))) return true;
              if (match(id(slot5_code), id(slot5_bits))) return true;
              if (match(id(slot6_code), id(slot6_bits))) return true;
              if (match(id(slot7_code), id(slot7_bits))) return true;
              if (match(id(slot8_code), id(slot8_bits))) return true;
              if (match(id(slot9_code), id(slot9_bits))) return true;
              if (match(id(slot10_code), id(slot10_bits))) return true;
              if (match(id(slot11_code), id(slot11_bits))) return true;
              if (match(id(slot12_code), id(slot12_bits))) return true;
              if (match(id(slot13_code), id(slot13_bits))) return true;
              if (match(id(slot14_code), id(slot14_bits))) return true;
              if (match(id(slot15_code), id(slot15_bits))) return true;
              if (match(id(slot16_code), id(slot16_bits))) return true;
              return false;
          then:
            - logger.log: "Matched stored keyfob → Relay2 pulse (10s)"
            - switch.turn_on: relay2
            - delay: 10s
            - switch.turn_off: relay2

  on_raw:
    then:
      - if:
          condition:
            lambda: |-
              if (!id(is_learning)) return false;
              if (id(rf_protocol_select).state != "Raw") return false;
              if ((int)x.size() < (int) id(rf_min_raw_timings).state) return false;
              uint32_t now = millis();
              if (now - id(last_rx_ms) < (uint32_t) id(rf_quiet_ms).state) return false;
              id(last_rx_ms) = now;
              return true;
          then:
            - lambda: |-
                id(learned_raw).clear();
                id(learned_raw).reserve(x.size());
                for (auto v : x) { id(learned_raw).push_back(v); }
                id(learned_type) = std::string("raw");
                ESP_LOGI("rf", "Learned RAW timings: count=%u", (unsigned) id(learned_raw).size());
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

remote_transmitter:
  pin: GPIO2
  carrier_duty_percent: 100%

# ---------------- Globals (incl. 16 slots) ----------------
globals:
  - { id: is_learning,      type: bool,                 restore_value: false, initial_value: 'false' }
  - { id: learned_type,     type: std::string,          restore_value: true,  initial_value: '"none"' }
  - { id: learned_code,     type: uint64_t,             restore_value: true,  initial_value: '0' }
  - { id: learned_bits,     type: uint8_t,              restore_value: true,  initial_value: '24' }
  - { id: learned_bin,      type: std::string,          restore_value: true,  initial_value: '""' }
  - { id: learned_raw,      type: std::vector<int32_t>, restore_value: false, initial_value: 'std::vector<int32_t>()' }
  - { id: last_a1_logged,   type: float,                restore_value: false, initial_value: 'NAN' }
  - { id: last_a2_logged,   type: float,                restore_value: false, initial_value: 'NAN' }
  - { id: last_rx_ms,       type: uint32_t,             restore_value: false, initial_value: '0' }

  - { id: slot1_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot2_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot3_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot4_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot5_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot6_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot7_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot8_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot9_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot10_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot11_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot12_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot13_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot14_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot15_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot16_code, type: uint64_t, restore_value: true, initial_value: '0' }

  - { id: slot1_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot2_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot3_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot4_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot5_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot6_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot7_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot8_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot9_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot10_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot11_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot12_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot13_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot14_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot15_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot16_bits, type: uint8_t, restore_value: true, initial_value: '0' }

# ---------------- UI controls (selects & numbers & status text) ----------------
select:
  - platform: template
    id: rf_protocol_select
    name: "RF Protocol"
    optimistic: true
    options:
      - "Auto (rc_switch)"
      - "Protocol 1"
      - "Protocol 2"
      - "Protocol 3"
      - "Protocol 4"
      - "Protocol 5"
      - "Protocol 6"
      - "Raw"
    initial_option: "Auto (rc_switch)"

number:
  - platform: template
    id: rf_repeat
    name: "RF Repeat"
    min_value: 1
    max_value: 30
    step: 1
    optimistic: true
    initial_value: 10

  - platform: template
    id: rf_pulse_len
    name: "RF Pulse Length (µs)"
    min_value: 200
    max_value: 600
    step: 10
    optimistic: true
    initial_value: 350

  - platform: template
    id: slot_select
    name: "RF Slot"
    min_value: 1
    max_value: 16
    step: 1
    optimistic: true
    initial_value: 1

  - platform: template
    id: rf_min_bits
    name: "RF Min Bits"
    min_value: 1
    max_value: 64
    step: 1
    optimistic: true
    initial_value: 20

  - platform: template
    id: rf_min_raw_timings
    name: "RF Min RAW Timings"
    min_value: 0
    max_value: 200
    step: 5
    optimistic: true
    initial_value: 40

  - platform: template
    id: rf_quiet_ms
    name: "RF Quiet (ms)"
    min_value: 0
    max_value: 2000
    step: 50
    optimistic: true
    initial_value: 200

text_sensor:
  - platform: template
    id: learned_status
    name: "RF Learned Status"
    update_interval: 2s
    lambda: |-
      if (id(learned_type) == "rc_switch" && id(learned_bin).size() > 0) {
        char buf[64];
        snprintf(buf, sizeof(buf), "rc_switch: bits=%u code=%llu",
                 id(learned_bits), (unsigned long long) id(learned_code));
        return std::string(buf);
      } else if (id(learned_type) == "raw" && !id(learned_raw).empty()) {
        char buf[64];
        snprintf(buf, sizeof(buf), "raw: %u timings", (unsigned) id(learned_raw).size());
        return std::string(buf);
      }
      return std::string("none");

# ---------------- PCF8574 expanders ----------------
pcf8574:
  - id: pcf8574_hub_out_1
    address: 0x24
  - id: pcf8574_hub_in_1
    address: 0x22

# ---------------- Relays ----------------
switch:
  - platform: gpio
    id: relay1
    name: "relay1"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 0
      inverted: true

  - platform: gpio
    id: relay2
    name: "relay2"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 1
      inverted: true

  - platform: gpio
    id: relay3
    name: "relay3"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 2
      inverted: true

  - platform: gpio
    id: relay4
    name: "relay4"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 3
      inverted: true

  - platform: gpio
    id: relay5
    name: "relay5"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 4
      inverted: true

  - platform: gpio
    id: relay6
    name: "relay6"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 5
      inverted: true

  - platform: gpio
    id: relay7
    name: "relay7"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 6
      inverted: true

  - platform: gpio
    id: relay8
    name: "relay8 (learning indicator)"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 7
      inverted: true

# ---------------- ADC with threshold + change-only logging ----------------
sensor:
  - platform: adc
    id: a1_volts
    name: "A1 Voltage"
    pin: GPIO34
    attenuation: 12db
    update_interval: 300ms
    filters:
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a1_logged)) || fabsf(x - id(last_a1_logged)) >= eps) {
              id(last_a1_logged) = x;
              ESP_LOGI("a1", "A1 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - if:
              condition:
                not:
                  switch.is_on: relay1
              then:
                - switch.turn_on: relay1
      - below: 1.95
        then:
          - if:
              condition:
                switch.is_on: relay1
              then:
                - switch.turn_off: relay1

  - platform: adc
    id: a2_volts
    name: "A2 Voltage"
    pin: GPIO35
    attenuation: 12db
    update_interval: 300ms
    filters:
      - throttle: 1s
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a2_logged)) || fabsf(x - id(last_a2_logged)) >= eps) {
              id(last_a2_logged) = x;
              ESP_LOGI("a2", "A2 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - script.execute: send_learned_rf

# ---------------- Digital inputs ----------------
binary_sensor:
  - platform: gpio
    id: input1
    name: "input1 (learn RF)"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 0
      inverted: true
    filters:
      - delayed_on_off: 20ms
    on_press:
      - script.execute: start_learning

  - platform: gpio
    id: input2
    name: "input2"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 1
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input3
    name: "input3"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 2
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input4
    name: "input4"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 3
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input5
    name: "input5"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 4
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input6
    name: "input6"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 5
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input7
    name: "input7"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 6
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input8
    name: "input8"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 7
      inverted: true
    filters:
      - delayed_on_off: 20ms

# ---------------- Buttons -> scripts ----------------
button:
  - platform: template
    id: start_rf_learning_ui
    name: "Start RF learning (UI)"
    on_press:
      - script.execute: start_learning

  - platform: template
    id: transmit_learned_433
    name: "Transmit learned 433"
    on_press:
      - script.execute: send_learned_rf

  - platform: template
    id: save_learned_slot
    name: "Save learned slot"
    on_press:
      - script.execute: save_learned_to_slot

  - platform: template
    id: transmit_slot
    name: "Transmit slot"
    on_press:
      - script.execute: tx_slot_script

  - platform: template
    id: clear_slot
    name: "Clear slot"
    on_press:
      - script.execute: clear_slot_script

  - platform: template
    id: learn_to_selected_slot
    name: "Learn to selected slot"
    on_press:
      - script.execute: start_learning
      - delay: 15s
      - script.execute: save_learned_to_slot

  - platform: template
    id: log_learned_values
    name: "Log learned values"
    on_press:
      - lambda: |-
          ESP_LOGI("rf", "Type=%s code=%llu bits=%u raw_count=%u",
            id(learned_type).c_str(), (unsigned long long) id(learned_code),
            id(learned_bits), (unsigned) id(learned_raw).size());

# ---------------- Scripts ----------------
script:
  - id: start_learning
    mode: restart
    then:
      - lambda: 'id(is_learning) = true;'
      - switch.turn_on: relay8
      - lambda: |-
          ESP_LOGI("rf", "Learning mode: %s (15s)", id(rf_protocol_select).state.c_str());
      - delay: 15s
      - if:
          condition:
            lambda: 'return id(is_learning);'
          then:
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8
            - lambda: 'ESP_LOGW("rf", "Learning timed out.");'

  - id: send_learned_rf
    mode: queued
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Raw";'
          then:
            - if:
                condition:
                  lambda: 'return !id(learned_raw).empty();'
                then:
                  - remote_transmitter.transmit_raw:
                      code: !lambda 'return id(learned_raw);'
                      repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
                else:
                  - logger.log: "No RAW timing learned."
          else:
            - if:
                condition:
                  lambda: 'return id(learned_bin).size() > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
                      then:
                        - script.execute: send_rc_switch_300
                      else:
                        - if:
                            condition:
                              lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                            then:
                              - script.execute: send_rc_switch_350
                            else:
                              - script.execute: send_rc_switch_433
                else:
                  - logger.log: "No rc_switch code learned."

  - id: save_learned_to_slot
    mode: queued
    then:
      - lambda: |-
          if (id(learned_type) != "rc_switch" || id(learned_bin).size() == 0) {
            ESP_LOGW("rf", "Save aborted: learned type is not rc_switch.");
            return;
          }
          const int s = (int) id(slot_select).state;
          const uint64_t code = id(learned_code);
          const uint8_t  bits = id(learned_bits);
          switch (s) {
            case 1:  id(slot1_code)=code;  id(slot1_bits)=bits;  break;
            case 2:  id(slot2_code)=code;  id(slot2_bits)=bits;  break;
            case 3:  id(slot3_code)=code;  id(slot3_bits)=bits;  break;
            case 4:  id(slot4_code)=code;  id(slot4_bits)=bits;  break;
            case 5:  id(slot5_code)=code;  id(slot5_bits)=bits;  break;
            case 6:  id(slot6_code)=code;  id(slot6_bits)=bits;  break;
            case 7:  id(slot7_code)=code;  id(slot7_bits)=bits;  break;
            case 8:  id(slot8_code)=code;  id(slot8_bits)=bits;  break;
            case 9:  id(slot9_code)=code;  id(slot9_bits)=bits;  break;
            case 10: id(slot10_code)=code; id(slot10_bits)=bits; break;
            case 11: id(slot11_code)=code; id(slot11_bits)=bits; break;
            case 12: id(slot12_code)=code; id(slot12_bits)=bits; break;
            case 13: id(slot13_code)=code; id(slot13_bits)=bits; break;
            case 14: id(slot14_code)=code; id(slot14_bits)=bits; break;
            case 15: id(slot15_code)=code; id(slot15_bits)=bits; break;
            case 16: id(slot16_code)=code; id(slot16_bits)=bits; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Saved rc_switch to slot %d: bits=%u code=%llu",
                   s, bits, (unsigned long long) code);
      # give Preferences time to flush (paired with flash_write_interval)
      - delay: 6s
      - logger.log: "Saved to flash."

  - id: clear_slot_script
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          switch (s) {
            case 1:  id(slot1_code)=0;  id(slot1_bits)=0;  break;
            case 2:  id(slot2_code)=0;  id(slot2_bits)=0;  break;
            case 3:  id(slot3_code)=0;  id(slot3_bits)=0;  break;
            case 4:  id(slot4_code)=0;  id(slot4_bits)=0;  break;
            case 5:  id(slot5_code)=0;  id(slot5_bits)=0;  break;
            case 6:  id(slot6_code)=0;  id(slot6_bits)=0;  break;
            case 7:  id(slot7_code)=0;  id(slot7_bits)=0;  break;
            case 8:  id(slot8_code)=0;  id(slot8_bits)=0;  break;
            case 9:  id(slot9_code)=0;  id(slot9_bits)=0;  break;
            case 10: id(slot10_code)=0; id(slot10_bits)=0; break;
            case 11: id(slot11_code)=0; id(slot11_bits)=0; break;
            case 12: id(slot12_code)=0; id(slot12_bits)=0; break;
            case 13: id(slot13_code)=0; id(slot13_bits)=0; break;
            case 14: id(slot14_code)=0; id(slot14_bits)=0; break;
            case 15: id(slot15_code)=0; id(slot15_bits)=0; break;
            case 16: id(slot16_code)=0; id(slot16_bits)=0; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Cleared slot %d", s)
      - delay: 6s
      - logger.log: "Cleared from flash."

  - id: tx_slot_script
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          uint64_t code = 0; uint8_t bits = 0;
          switch (s) {
            case 1:  code=id(slot1_code);  bits=id(slot1_bits);  break;
            case 2:  code=id(slot2_code);  bits=id(slot2_bits);  break;
            case 3:  code=id(slot3_code);  bits=id(slot3_bits);  break;
            case 4:  code=id(slot4_code);  bits=id(slot4_bits);  break;
            case 5:  code=id(slot5_code);  bits=id(slot5_bits);  break;
            case 6:  code=id(slot6_code);  bits=id(slot6_bits);  break;
            case 7:  code=id(slot7_code);  bits=id(slot7_bits);  break;
            case 8:  code=id(slot8_code);  bits=id(slot8_bits);  break;
            case 9:  code=id(slot9_code);  bits=id(slot9_bits);  break;
            case 10: code=id(slot10_code); bits=id(slot10_bits); break;
            case 11: code=id(slot11_code); bits=id(slot11_bits); break;
            case 12: code=id(slot12_code); bits=id(slot12_bits); break;
            case 13: code=id(slot13_code); bits=id(slot13_bits); break;
            case 14: code=id(slot14_code); bits=id(slot14_bits); break;
            case 15: code=id(slot15_code); bits=id(slot15_bits); break;
            case 16: code=id(slot16_code); bits=id(slot16_bits); break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          if (code == 0 || bits == 0) {
            ESP_LOGW("rf", "Slot %d empty", s);
            return;
          }
          std::string bin; bin.reserve(bits);
          for (int i = bits - 1; i >= 0; --i)
            bin.push_back((code & (1ULL << i)) ? '1' : '0');
          id(learned_bin) = bin;
      - if:
          condition:
            lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
          then:
            - script.execute: send_rc_switch_300
          else:
            - if:
                condition:
                  lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                then:
                  - script.execute: send_rc_switch_350
                else:
                  - script.execute: send_rc_switch_433

  # protocol helpers
  - id: send_rc_switch_300
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 300, sync: [1,10], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 300, sync: [30,71], zero: [4,11], one: [9,6] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 300, sync: [1,6], zero: [1,3], one: [3,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 300, sync: [6,14], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 300, sync: [1,23], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }

  - id: send_rc_switch_350
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 350, sync: [1,10], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 350, sync: [30,71], zero: [4,11], one: [9,6] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 350, sync: [1,6], zero: [1,3], one: [3,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 350, sync: [6,14], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 350, sync: [1,23], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }

  - id: send_rc_switch_433
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 433, sync: [1,10], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 433, sync: [30,71], zero: [4,11], one: [9,6] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 433, sync: [1,6], zero: [1,3], one: [3,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 433, sync: [6,14], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }
      - if: { condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }, then: [ { remote_transmitter.transmit_rc_switch_raw: { code: !lambda 'return id(learned_bin);', protocol: { pulse_length: 433, sync: [1,23], zero: [1,2], one: [2,1] }, repeat: !lambda 'return (uint32_t) id(rf_repeat).state;' } } ] }

# ---------------- Logging / API ----------------
logger:
  level: DEBUG

api:
