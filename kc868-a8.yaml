substitutions:
  name: kc868-a8

esphome:
  name: ${name}
  name_add_mac_suffix: true
  project:
    name: kincony.kc868-a8
    version: "1"

esp32:
  board: esp32dev
  framework:
    type: arduino

web_server:
  port: 80

dashboard_import:
  package_import_url: github://hzkincony/kc868-a8/kc868-a8.yaml@main

ota:
  - platform: esphome
    password: "bobthebuilder"

# I2C
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

# Ethernet (new 'clk' style)
ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT
  phy_addr: 0

# ---------- 433 MHz RF ----------
remote_receiver:
  pin: GPIO2         # KC868-A8 RX
  dump:
    - rc_switch
  tolerance: 50%
  filter: 250us
  idle: 4ms
  on_rc_switch:
    then:
      - if:
          condition:
            lambda: |-
              return id(is_learning);
          then:
            - lambda: |-
                // Save numeric code
                id(learned_code) = x.code;
                // Infer bit length from code (keeps leading zeros via bitstring below)
                uint8_t bits = 64 - __builtin_clzll(x.code);
                if (bits == 0) bits = id(learned_bits);
                id(learned_bits) = bits;

                // Build exact bitstring (leading zeros preserved)
                std::string s;
                s.reserve(bits);
                for (int i = bits - 1; i >= 0; --i) {
                  s.push_back((x.code & (1ULL << i)) ? '1' : '0');
                }
                id(learned_bin) = s;

                ESP_LOGI("rf", "Learned rc_switch: code=%llu bits=%u bin=%s",
                         id(learned_code), id(learned_bits), id(learned_bin).c_str());
            - lambda: |-
                id(is_learning) = false;
            - switch.turn_off: relay8  # indicator off

remote_transmitter:
  pin: GPIO15        # KC868-A8 TX
  carrier_duty_percent: 100%

# Persist learned RF
globals:
  - id: is_learning
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: learned_code
    type: uint64_t
    restore_value: yes
    initial_value: '0'
  - id: learned_bits
    type: uint8_t
    restore_value: yes
    initial_value: '24'
  - id: learned_bin
    type: std::string
    restore_value: yes
    initial_value: '""'

# Optional: tweak bit length in UI if needed
number:
  - platform: template
    id: rc_bits
    name: "433 Learned Bits"
    min_value: 1
    max_value: 64
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 24
    on_value:
      then:
        - lambda: |-
            id(learned_bits) = (uint8_t) x;
            // Rebuild bitstring to the desired length from numeric code
            std::string s;
            s.reserve(id(learned_bits));
            for (int i = id(learned_bits) - 1; i >= 0; --i) {
              s.push_back((id(learned_code) & (1ULL << i)) ? '1' : '0');
            }
            id(learned_bin) = s;

# ---------- PCF8574 expanders ----------
pcf8574:
  - id: pcf8574_hub_out_1   # outputs 1–8
    address: 0x24
  - id: pcf8574_hub_in_1    # inputs 1–8
    address: 0x22

# ---------- Relays (active-low) ----------
switch:
  - platform: gpio
    id: relay1
    name: "relay1"
    pin: { pcf8574: pcf8574_hub_out_1, number: 0, inverted: true }

  - platform: gpio
    id: relay2
    name: "relay2"
    pin: { pcf8574: pcf8574_hub_out_1, number: 1, inverted: true }

  - platform: gpio
    id: relay3
    name: "relay3"
    pin: { pcf8574: pcf8574_hub_out_1, number: 2, inverted: true }

  - platform: gpio
    id: relay4
    name: "relay4"
    pin: { pcf8574: pcf8574_hub_out_1, number: 3, inverted: true }

  - platform: gpio
    id: relay5
    name: "relay5"
    pin: { pcf8574: pcf8574_hub_out_1, number: 4, inverted: true }

  - platform: gpio
    id: relay6
    name: "relay6"
    pin: { pcf8574: pcf8574_hub_out_1, number: 5, inverted: true }

  - platform: gpio
    id: relay7
    name: "relay7"
    pin: { pcf8574: pcf8574_hub_out_1, number: 6, inverted: true }

  - platform: gpio
    id: relay8
    name: "relay8 (learning indicator)"
    pin: { pcf8574: pcf8574_hub_out_1, number: 7, inverted: true }

# ---------- A1 → Relay1 threshold ----------
sensor:
  - platform: adc
    id: a1_volts
    name: "A1 Voltage"
    pin: GPIO34
    attenuation: 11db
    update_interval: 300ms
    filters:
      - median: { window_size: 5, send_every: 2, send_first_at: 1 }
      # map ADC (~0–3.3 V) back to terminal 0–5 V
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value_range:
      - above: 2.05
        then:
          - if:
              condition:
                not: { switch.is_on: relay1 }
              then:
                - switch.turn_on: relay1
      - below: 1.95
        then:
          - if:
              condition:
                switch.is_on: relay1
              then:
                - switch.turn_off: relay1

  # ---------- A2 → transmit learned 433 when >2.0 V ----------
  - platform: adc
    id: a2_volts
    name: "A2 Voltage"
    pin: GPIO35
    attenuation: 11db
    update_interval: 300ms
    filters:
      - throttle: 1s
      - median: { window_size: 5, send_every: 2, send_first_at: 1 }
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value_range:
      - above: 2.05
        then:
          - script.execute: send_learned_rf

# ---------- Digital inputs ----------
binary_sensor:
  # DI1: enter learning mode (Relay8 = indicator, 15 s window)
  - platform: gpio
    id: input1
    name: "input1 (learn RF)"
    pin: { pcf8574: pcf8574_hub_in_1, number: 0, inverted: true }
    filters: [ delayed_on_off: 20ms ]
    on_press:
      - script.execute: start_learning

  - platform: gpio
    id: input2
    name: "input2"
    pin: { pcf8574: pcf8574_hub_in_1, number: 1, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input3
    name: "input3"
    pin: { pcf8574: pcf8574_hub_in_1, number: 2, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input4
    name: "input4"
    pin: { pcf8574: pcf8574_hub_in_1, number: 3, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input5
    name: "input5"
    pin: { pcf8574: pcf8574_hub_in_1, number: 4, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input6
    name: "input6"
    pin: { pcf8574: pcf8574_hub_in_1, number: 5, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input7
    name: "input7"
    pin: { pcf8574: pcf8574_hub_in_1, number: 6, inverted: true }
    filters: [ delayed_on_off: 20ms ]

  - platform: gpio
    id: input8
    name: "input8"
    pin: { pcf8574: pcf8574_hub_in_1, number: 7, inverted: true }
    filters: [ delayed_on_off: 20ms ]

# ---------- UI button to transmit learned code ----------
button:
  - platform: template
    name: "Transmit learned 433"
    on_press:
      - if:
          condition:
            lambda: 'return id(learned_bin).size() > 0;'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                # RC-Switch Protocol 1 timings
                protocol:
                  pulse_length: 350us
                  sync: [1, 31]
                  zero: [1, 3]
                  one: [3, 1]
                repeat:
                  times: 10
                  wait_time: 0s
          else:
            - logger.log: "No learned RF code yet."

# ---------- Scripts ----------
script:
  - id: start_learning
    mode: restart
    then:
      - lambda: 'id(is_learning) = true;'
      - switch.turn_on: relay8
      - logger.log: "Learning mode started (15s)..."
      - delay: 15s
      - if:
          condition:
            lambda: 'return id(is_learning);'
          then:
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8
            - logger.log: "Learning timed out."

  - id: send_learned_rf
    mode: queued
    then:
      - if:
          condition:
            lambda: 'return id(learned_bin).size() > 0;'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                # RC-Switch Protocol 1 timings
                protocol:
                  pulse_length: 350us
                  sync: [1, 31]
                  zero: [1, 3]
                  one: [3, 1]
                repeat:
                  times: 10
                  wait_time: 0s
          else:
            - logger.log: "Analog triggered, but no RF code learned yet."

# Logging / API
logger:
  level: DEBUG
api:
