substitutions:
  name: kc868-a8

esphome:
  name: ${name}
  name_add_mac_suffix: true
  project:
    name: kincony.kc868-a8
    version: "1"
  on_boot:
    priority: 600
    then:
      - switch.turn_off: relay2

esp32:
  board: esp32dev
  framework:
    type: arduino

# -------------------------------------------------------------------
# Web server + same-origin UI served at / and /ui and /ui.js
# -------------------------------------------------------------------
web_server:
  port: 80
  include_internal: true
  on_request:
    - lambda: |-
        std::string path = request->url()->path();

        // Serve UI HTML on / and /ui
        if (path == "/" || path == "/ui") {
          static const char kHtml[] PROGMEM = R"HTML(
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KC868-A8 Control</title>
  <link rel="preconnect" href="/" />
  <style>
    :root { --bg:#0b0f17; --card:#111827; --text:#e5e7eb; --muted:#9ca3af; --accent:#60a5fa; --good:#10b981; --warn:#f59e0b; --bad:#ef4444; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,'Noto Sans',sans-serif; background:var(--bg); color:var(--text); }
    header { padding:16px 20px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #1f2937; }
    header h1 { margin:0; font-size:18px; letter-spacing:.4px; }
    main { padding:20px; display:grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap:16px; }
    .card { background:var(--card); border:1px solid #1f2937; border-radius:16px; padding:16px; box-shadow: 0 10px 20px rgba(0,0,0,.25); }
    .card h2 { margin:0 0 10px 0; font-size:14px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    button, select, input[type="number"], input[type="range"] {
      background:#0f172a; color:var(--text); border:1px solid #334155; border-radius:12px; padding:10px 12px;
      font-size:14px; cursor:pointer; outline:none; transition:.15s; min-height:40px;
    }
    button:hover { border-color:var(--accent); box-shadow: 0 0 0 2px rgba(96,165,250,.2) inset; }
    .pill { border-radius:999px; }
    .ok { color: var(--good); }
    .warn { color: var(--warn); }
    .bad { color: var(--bad); }
    .grid { display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; }
    .full { grid-column: 1 / -1; }
    .label { font-size:12px; color: var(--muted); margin-bottom:6px; }
    .row input[type="range"] { width: 180px; }
    footer { padding: 8px 20px 24px; color:var(--muted); font-size:12px; }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>KC868-A8 · Local Control UI</h1>
    <div id="status" class="warn">checking…</div>
  </header>

  <main>
    <section class="card">
      <h2>Relays</h2>
      <div class="grid">
        <button onclick="ESPUI.relayToggle(1)">Relay 1 Toggle</button>
        <button onclick="ESPUI.relayToggle(2)">Relay 2 Toggle</button>
        <button onclick="ESPUI.relayToggle(3)">Relay 3 Toggle</button>
        <button onclick="ESPUI.relayToggle(4)">Relay 4 Toggle</button>
        <button onclick="ESPUI.relayToggle(5)">Relay 5 Toggle</button>
        <button onclick="ESPUI.relayToggle(6)">Relay 6 Toggle</button>
        <button onclick="ESPUI.relayToggle(7)">Relay 7 Toggle</button>
        <button onclick="ESPUI.relayToggle(8)">Relay 8 Toggle</button>
      </div>
    </section>

    <section class="card">
      <h2>RF — Learning & Actions</h2>
      <div class="row">
        <button class="pill" onclick="ESPUI.startLearning()">Start Learning</button>
        <button class="pill" onclick="ESPUI.txLearned()">Transmit Learned</button>
        <button class="pill" onclick="ESPUI.saveSlot()">Save → Slot</button>
        <button class="pill" onclick="ESPUI.txSlot()">Transmit Slot</button>
        <button class="pill" onclick="ESPUI.clearSlot()">Clear Slot</button>
        <button class="pill" onclick="ESPUI.learnToSlot()">Learn→Save Slot (15s)</button>
        <button class="pill" onclick="ESPUI.logLearned()">Log Learned</button>
      </div>
      <div class="row" style="margin-top:12px;">
        <div>
          <div class="label">Protocol</div>
          <select id="proto" onchange="ESPUI.setProtocol(this.value)">
            <option>Auto (rc_switch)</option>
            <option>Protocol 1</option>
            <option>Protocol 2</option>
            <option>Protocol 3</option>
            <option>Protocol 4</option>
            <option>Protocol 5</option>
            <option>Protocol 6</option>
            <option>Raw</option>
          </select>
        </div>
        <div>
          <div class="label">Repeat</div>
          <input type="number" min="1" max="30" value="10" oninput="ESPUI.setRepeat(this.value)">
        </div>
        <div>
          <div class="label">Pulse (µs)</div>
          <input type="number" min="200" max="600" step="10" value="350" oninput="ESPUI.setPulse(this.value)">
        </div>
        <div>
          <div class="label">Slot</div>
          <input type="number" min="1" max="16" value="1" oninput="ESPUI.setSlot(this.value)">
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <div>
          <div class="label">Squelch: Min Bits</div>
          <input type="range" min="1" max="64" value="20" oninput="ESPUI.setMinBits(this.value)">
        </div>
        <div>
          <div class="label">Squelch: Min RAW Timings</div>
          <input type="range" min="0" max="200" step="5" value="40" oninput="ESPUI.setMinRaw(this.value)">
        </div>
        <div>
          <div class="label">Squelch: Quiet (ms)</div>
          <input type="range" min="0" max="2000" step="50" value="200" oninput="ESPUI.setQuietMs(this.value)">
        </div>
      </div>
    </section>

    <section class="card">
      <h2>Saved Codes (read-only here)</h2>
      <div class="row">
        <small>Use HA/ESPHome to view live slot sensors; we can extend this page later to poll same-origin.</small>
      </div>
    </section>
  </main>

  <footer>
    Same-origin UI served by ESPHome. Endpoints called relative to this device.
  </footer>

  <script src="/ui.js"></script>
</body>
</html>
          )HTML";
          request->send(200, "text/html; charset=utf-8", kHtml);
          return;
        }

        // Serve JS
        if (path == "/ui.js") {
          static const char kJs[] PROGMEM = R"JS(
// === no-CORS same-origin helpers (Image beacon) =========================
function fireGet(path, timeoutMs = 4000, cb) {
  const img = new Image();
  let done = false;
  const timer = setTimeout(() => {
    if (done) return; done = true; cb && cb(false);
  }, timeoutMs);
  img.onload = () => { if (done) return; done = true; clearTimeout(timer); cb && cb(true); };
  img.onerror = () => { if (done) return; done = true; clearTimeout(timer); cb && cb(false); };
  img.src = `${path}${path.includes('?') ? '&' : '?'}_=${Date.now()}`;
}

// Status light (optional ping)
(function(){
  const el = document.getElementById('status');
  fireGet('/', 2500, ok => {
    if (!el) return;
    el.textContent = ok ? 'online' : 'offline';
    el.className = ok ? 'ok' : 'bad';
  });
})();

// Relays
window.ESPUI = {
  relayToggle(n){ fireGet(`/switch/relay${n}/toggle`, 4000, ok => console.log('toggle', n, ok)); },
  relayOn(n){ fireGet(`/switch/relay${n}?turn=on`, 4000, ok => console.log('on', n, ok)); },
  relayOff(n){ fireGet(`/switch/relay${n}?turn=off`, 4000, ok => console.log('off', n, ok)); },

  // RF buttons (match YAML button ids)
  startLearning(){ fireGet(`/button/start_rf_learning_ui/press`, 4000, ok => console.log('learn', ok)); },
  txLearned(){     fireGet(`/button/transmit_learned_433/press`, 4000, ok => console.log('tx learned', ok)); },
  saveSlot(){      fireGet(`/button/save_learned_slot/press`, 4000, ok => console.log('save slot', ok)); },
  txSlot(){        fireGet(`/button/transmit_slot/press`, 4000, ok => console.log('tx slot', ok)); },
  clearSlot(){     fireGet(`/button/clear_slot/press`, 4000, ok => console.log('clear slot', ok)); },
  learnToSlot(){   fireGet(`/button/learn_to_selected_slot/press`, 4000, ok => console.log('learn->slot', ok)); },
  logLearned(){    fireGet(`/button/log_learned_values/press`, 4000, ok => console.log('log', ok)); },

  // Numbers
  setNumber(id, v){
    const try1 = `/number/${encodeURIComponent(id)}/set?value=${encodeURIComponent(v)}`;
    fireGet(try1, 4000, ok => {
      if (ok) return;
      const try2 = `/number/${encodeURIComponent(id)}?value=${encodeURIComponent(v)}`;
      fireGet(try2, 4000, ok2 => console.log('number', id, ok2));
    });
  },

  setRepeat(v){ this.setNumber('rf_repeat', v); },
  setPulse(v){ this.setNumber('rf_pulse_len', v); },
  setSlot(v){ this.setNumber('slot_select', v); },
  setMinBits(v){ this.setNumber('rf_min_bits', v); },
  setMinRaw(v){ this.setNumber('rf_min_raw_timings', v); },
  setQuietMs(v){ this.setNumber('rf_quiet_ms', v); },

  // Select (try /set then /select)
  setProtocol(label){
    const try1 = `/select/rf_protocol_select/set?option=${encodeURIComponent(label)}`;
    fireGet(try1, 4000, ok => {
      if (ok) return;
      const try2 = `/select/rf_protocol_select/select?option=${encodeURIComponent(label)}`;
      fireGet(try2, 4000, ok2 => console.log('proto', ok2));
    });
  }
};
          )JS";
          request->send(200, "application/javascript; charset=utf-8", kJs);
          return;
        }
        // Otherwise let ESPHome handle (404 etc.)

dashboard_import:
  package_import_url: github://hzkincony/kc868-a8/kc868-a8.yaml@main

ota:
  - platform: esphome
    password: "bobthebuilder"

# -------------------------------------------------------------------
# I2C / Ethernet
# -------------------------------------------------------------------
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT
  phy_addr: 0

# -------------------------------------------------------------------
# 433 MHz RF (RX=GPIO15, TX=GPIO2)
# -------------------------------------------------------------------
remote_receiver:
  pin:
    number: GPIO15
    mode: INPUT_PULLDOWN
  dump:
    - rc_switch
    - raw
  tolerance: 65%
  filter: 100us
  idle: 8ms

  on_rc_switch:
    then:
      - if:
          condition:
            lambda: |-
              uint8_t bits = 64 - __builtin_clzll(x.code);
              if (bits < (uint8_t) id(rf_min_bits).state) return false;
              uint32_t now = millis();
              if (now - id(last_rx_ms) < (uint32_t) id(rf_quiet_ms).state) return false;
              id(last_rx_ms) = now;
              return id(is_learning) && id(rf_protocol_select).state == "Auto (rc_switch)";
          then:
            - lambda: |-
                id(learned_code) = x.code;
                uint8_t bits = 64 - __builtin_clzll(x.code);
                if (bits == 0) bits = id(learned_bits);
                id(learned_bits) = bits;
                std::string s; s.reserve(bits);
                for (int i = bits - 1; i >= 0; --i)
                  s.push_back((x.code & (1ULL << i)) ? '1' : '0');
                id(learned_bin) = s;
                id(learned_type) = std::string("rc_switch");
                ESP_LOGI("rf", "Learned rc_switch: code=%llu bits=%u",
                         (unsigned long long) id(learned_code), id(learned_bits));
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

      - if:
          condition:
            lambda: |-
              if (id(is_learning)) return false;
              uint8_t bits = 64 - __builtin_clzll(x.code);
              if (bits < (uint8_t) id(rf_min_bits).state) return false;
              uint32_t now = millis();
              if (now - id(last_rx_ms) < (uint32_t) id(rf_quiet_ms).state) return false;
              id(last_rx_ms) = now;

              auto match = [&](uint64_t c, uint8_t b){ return (c!=0 && b==bits && c==x.code); };
              if (match(id(slot1_code), id(slot1_bits))) return true;
              if (match(id(slot2_code), id(slot2_bits))) return true;
              if (match(id(slot3_code), id(slot3_bits))) return true;
              if (match(id(slot4_code), id(slot4_bits))) return true;
              if (match(id(slot5_code), id(slot5_bits))) return true;
              if (match(id(slot6_code), id(slot6_bits))) return true;
              if (match(id(slot7_code), id(slot7_bits))) return true;
              if (match(id(slot8_code), id(slot8_bits))) return true;
              if (match(id(slot9_code), id(slot9_bits))) return true;
              if (match(id(slot10_code), id(slot10_bits))) return true;
              if (match(id(slot11_code), id(slot11_bits))) return true;
              if (match(id(slot12_code), id(slot12_bits))) return true;
              if (match(id(slot13_code), id(slot13_bits))) return true;
              if (match(id(slot14_code), id(slot14_bits))) return true;
              if (match(id(slot15_code), id(slot15_bits))) return true;
              if (match(id(slot16_code), id(slot16_bits))) return true;
              return false;
          then:
            - logger.log: "Matched stored keyfob → Relay2 pulse (10s)"
            - switch.turn_on: relay2
            - delay: 10s
            - switch.turn_off: relay2

  on_raw:
    then:
      - if:
          condition:
            lambda: |-
              if (!id(is_learning)) return false;
              if (id(rf_protocol_select).state != "Raw") return false;
              if ((int)x.size() < (int) id(rf_min_raw_timings).state) return false;
              uint32_t now = millis();
              if (now - id(last_rx_ms) < (uint32_t) id(rf_quiet_ms).state) return false;
              id(last_rx_ms) = now;
              return true;
          then:
            - lambda: |-
                id(learned_raw).clear();
                id(learned_raw).reserve(x.size());
                for (auto v : x) { id(learned_raw).push_back(v); }
                id(learned_type) = std::string("raw");
                ESP_LOGI("rf", "Learned RAW timings: count=%u", (unsigned) id(learned_raw).size());
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8

remote_transmitter:
  pin: GPIO2
  carrier_duty_percent: 100%

# -------------------------------------------------------------------
# Globals
# -------------------------------------------------------------------
globals:
  - { id: is_learning,      type: bool,                restore_value: false, initial_value: 'false' }
  - { id: learned_type,     type: std::string,         restore_value: true,  initial_value: '"none"' }
  - { id: learned_code,     type: uint64_t,            restore_value: true,  initial_value: '0' }
  - { id: learned_bits,     type: uint8_t,             restore_value: true,  initial_value: '24' }
  - { id: learned_bin,      type: std::string,         restore_value: true,  initial_value: '""' }
  - { id: learned_raw,      type: std::vector<int32_t>,restore_value: false, initial_value: 'std::vector<int32_t>()' }
  - { id: last_a1_logged,   type: float,               restore_value: false, initial_value: 'NAN' }
  - { id: last_a2_logged,   type: float,               restore_value: false, initial_value: 'NAN' }
  - { id: last_rx_ms,       type: uint32_t,            restore_value: false, initial_value: '0' }

  # 16 RF storage slots (code + bits)
  - { id: slot1_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot2_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot3_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot4_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot5_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot6_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot7_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot8_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot9_code,  type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot10_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot11_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot12_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot13_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot14_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot15_code, type: uint64_t, restore_value: true, initial_value: '0' }
  - { id: slot16_code, type: uint64_t, restore_value: true, initial_value: '0' }

  - { id: slot1_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot2_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot3_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot4_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot5_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot6_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot7_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot8_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot9_bits,  type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot10_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot11_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot12_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot13_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot14_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot15_bits, type: uint8_t, restore_value: true, initial_value: '0' }
  - { id: slot16_bits, type: uint8_t, restore_value: true, initial_value: '0' }

# -------------------------------------------------------------------
# UI controls (selects & numbers & status text)
# -------------------------------------------------------------------
select:
  - platform: template
    id: rf_protocol_select
    name: "RF Protocol"
    optimistic: true
    options:
      - "Auto (rc_switch)"
      - "Protocol 1"
      - "Protocol 2"
      - "Protocol 3"
      - "Protocol 4"
      - "Protocol 5"
      - "Protocol 6"
      - "Raw"
    initial_option: "Auto (rc_switch)"

number:
  - platform: template
    id: rf_repeat
    name: "RF Repeat"
    min_value: 1
    max_value: 30
    step: 1
    optimistic: true
    initial_value: 10

  - platform: template
    id: rf_pulse_len
    name: "RF Pulse Length (µs)"
    min_value: 200
    max_value: 600
    step: 10
    optimistic: true
    initial_value: 350

  - platform: template
    id: slot_select
    name: "RF Slot"
    min_value: 1
    max_value: 16
    step: 1
    optimistic: true
    initial_value: 1

  - platform: template
    id: rf_min_bits
    name: "RF Min Bits"
    min_value: 1
    max_value: 64
    step: 1
    optimistic: true
    initial_value: 20

  - platform: template
    id: rf_min_raw_timings
    name: "RF Min RAW Timings"
    min_value: 0
    max_value: 200
    step: 5
    optimistic: true
    initial_value: 40

  - platform: template
    id: rf_quiet_ms
    name: "RF Quiet (ms)"
    min_value: 0
    max_value: 2000
    step: 50
    optimistic: true
    initial_value: 200

text_sensor:
  - platform: template
    id: learned_status
    name: "RF Learned Status"
    update_interval: 2s
    lambda: |-
      if (id(learned_type) == "rc_switch" && id(learned_bin).size() > 0) {
        char buf[64];
        snprintf(buf, sizeof(buf), "rc_switch: bits=%u code=%llu",
                 id(learned_bits), (unsigned long long) id(learned_code));
        return std::string(buf);
      } else if (id(learned_type) == "raw" && !id(learned_raw).empty()) {
        char buf[64];
        snprintf(buf, sizeof(buf), "raw: %u timings", (unsigned) id(learned_raw).size());
        return std::string(buf);
      }
      return std::string("none");

# -------------------------------------------------------------------
# PCF8574 expanders
# -------------------------------------------------------------------
pcf8574:
  - id: pcf8574_hub_out_1
    address: 0x24
  - id: pcf8574_hub_in_1
    address: 0x22

# -------------------------------------------------------------------
# Relays
# -------------------------------------------------------------------
switch:
  - platform: gpio
    id: relay1
    name: "relay1"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 0
      inverted: true

  - platform: gpio
    id: relay2
    name: "relay2"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 1
      inverted: true

  - platform: gpio
    id: relay3
    name: "relay3"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 2
      inverted: true

  - platform: gpio
    id: relay4
    name: "relay4"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 3
      inverted: true

  - platform: gpio
    id: relay5
    name: "relay5"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 4
      inverted: true

  - platform: gpio
    id: relay6
    name: "relay6"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 5
      inverted: true

  - platform: gpio
    id: relay7
    name: "relay7"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 6
      inverted: true

  - platform: gpio
    id: relay8
    name: "relay8 (learning indicator)"
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 7
      inverted: true

# -------------------------------------------------------------------
# Analog inputs with thresholds + change-only logging
# -------------------------------------------------------------------
sensor:
  - platform: adc
    id: a1_volts
    name: "A1 Voltage"
    pin: GPIO34
    attenuation: 12db
    update_interval: 300ms
    filters:
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a1_logged)) || fabsf(x - id(last_a1_logged)) >= eps) {
              id(last_a1_logged) = x;
              ESP_LOGI("a1", "A1 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - if:
              condition:
                not:
                  switch.is_on: relay1
              then:
                - switch.turn_on: relay1
      - below: 1.95
        then:
          - if:
              condition:
                switch.is_on: relay1
              then:
                - switch.turn_off: relay1

  - platform: adc
    id: a2_volts
    name: "A2 Voltage"
    pin: GPIO35
    attenuation: 12db
    update_interval: 300ms
    filters:
      - throttle: 1s
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
      - calibrate_linear:
          - 0.00 -> 0.00
          - 3.30 -> 5.00
    on_value:
      then:
        - lambda: |-
            const float eps = 0.02f;
            if (isnan(id(last_a2_logged)) || fabsf(x - id(last_a2_logged)) >= eps) {
              id(last_a2_logged) = x;
              ESP_LOGI("a2", "A2 = %.3f V", x);
            }
    on_value_range:
      - above: 2.05
        then:
          - script.execute: send_learned_rf

# -------------------------------------------------------------------
# Digital inputs
# -------------------------------------------------------------------
binary_sensor:
  - platform: gpio
    id: input1
    name: "input1 (learn RF)"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 0
      inverted: true
    filters:
      - delayed_on_off: 20ms
    on_press:
      - script.execute: start_learning

  - platform: gpio
    id: input2
    name: "input2"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 1
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input3
    name: "input3"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 2
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input4
    name: "input4"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 3
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input5
    name: "input5"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 4
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input6
    name: "input6"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 5
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input7
    name: "input7"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 6
      inverted: true
    filters:
      - delayed_on_off: 20ms

  - platform: gpio
    id: input8
    name: "input8"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 7
      inverted: true
    filters:
      - delayed_on_off: 20ms

# -------------------------------------------------------------------
# Web UI buttons (trigger scripts/actions)
# -------------------------------------------------------------------
button:
  - platform: template
    id: start_rf_learning_ui
    name: "Start RF learning (UI)"
    on_press:
      - script.execute: start_learning

  - platform: template
    id: transmit_learned_433
    name: "Transmit learned 433"
    on_press:
      - script.execute: send_learned_rf

  - platform: template
    id: save_learned_slot
    name: "Save learned slot"
    on_press:
      - script.execute: save_learned_to_slot

  - platform: template
    id: transmit_slot
    name: "Transmit slot"
    on_press:
      - script.execute: tx_slot_script

  - platform: template
    id: clear_slot
    name: "Clear slot"
    on_press:
      - script.execute: clear_slot_script

  - platform: template
    id: learn_to_selected_slot
    name: "Learn to selected slot"
    on_press:
      - script.execute: start_learning
      - delay: 15s
      - script.execute: save_learned_to_slot

  - platform: template
    id: log_learned_values
    name: "Log learned values"
    on_press:
      - lambda: |-
          ESP_LOGI("rf", "Type=%s code=%llu bits=%u raw_count=%u",
            id(learned_type).c_str(), (unsigned long long) id(learned_code),
            id(learned_bits), (unsigned) id(learned_raw).size());

# -------------------------------------------------------------------
# Scripts
# -------------------------------------------------------------------
script:
  - id: start_learning
    mode: restart
    then:
      - lambda: 'id(is_learning) = true;'
      - switch.turn_on: relay8
      - lambda: |-
          ESP_LOGI("rf", "Learning mode: %s (15s)", id(rf_protocol_select).state.c_str());
      - delay: 15s
      - if:
          condition:
            lambda: 'return id(is_learning);'
          then:
            - lambda: 'id(is_learning) = false;'
            - switch.turn_off: relay8
            - lambda: 'ESP_LOGW("rf", "Learning timed out.");'

  - id: send_learned_rf
    mode: queued
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Raw";'
          then:
            - if:
                condition:
                  lambda: 'return !id(learned_raw).empty();'
                then:
                  - remote_transmitter.transmit_raw:
                      code: !lambda 'return id(learned_raw);'
                      repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
                else:
                  - logger.log: "No RAW timing learned."
          else:
            - if:
                condition:
                  lambda: 'return id(learned_bin).size() > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
                      then:
                        - script.execute: send_rc_switch_300
                      else:
                        - if:
                            condition:
                              lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                            then:
                              - script.execute: send_rc_switch_350
                            else:
                              - script.execute: send_rc_switch_433
                else:
                  - logger.log: "No rc_switch code learned."

  - id: save_learned_to_slot
    mode: queued
    then:
      - lambda: |-
          if (id(learned_type) != "rc_switch" || id(learned_bin).size() == 0) {
            ESP_LOGW("rf", "Save aborted: learned type is not rc_switch.");
            return;
          }
          const int s = (int) id(slot_select).state;
          const uint64_t code = id(learned_code);
          const uint8_t  bits = id(learned_bits);
          switch (s) {
            case 1:  id(slot1_code)=code;  id(slot1_bits)=bits;  break;
            case 2:  id(slot2_code)=code;  id(slot2_bits)=bits;  break;
            case 3:  id(slot3_code)=code;  id(slot3_bits)=bits;  break;
            case 4:  id(slot4_code)=code;  id(slot4_bits)=bits;  break;
            case 5:  id(slot5_code)=code;  id(slot5_bits)=bits;  break;
            case 6:  id(slot6_code)=code;  id(slot6_bits)=bits;  break;
            case 7:  id(slot7_code)=code;  id(slot7_bits)=bits;  break;
            case 8:  id(slot8_code)=code;  id(slot8_bits)=bits;  break;
            case 9:  id(slot9_code)=code;  id(slot9_bits)=bits;  break;
            case 10: id(slot10_code)=code; id(slot10_bits)=bits; break;
            case 11: id(slot11_code)=code; id(slot11_bits)=bits; break;
            case 12: id(slot12_code)=code; id(slot12_bits)=bits; break;
            case 13: id(slot13_code)=code; id(slot13_bits)=bits; break;
            case 14: id(slot14_code)=code; id(slot14_bits)=bits; break;
            case 15: id(slot15_code)=code; id(slot15_bits)=bits; break;
            case 16: id(slot16_code)=code; id(slot16_bits)=bits; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Saved rc_switch to slot %d: bits=%u code=%llu", s, bits, (unsigned long long) code);

  - id: clear_slot_script
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          switch (s) {
            case 1:  id(slot1_code)=0;  id(slot1_bits)=0;  break;
            case 2:  id(slot2_code)=0;  id(slot2_bits)=0;  break;
            case 3:  id(slot3_code)=0;  id(slot3_bits)=0;  break;
            case 4:  id(slot4_code)=0;  id(slot4_bits)=0;  break;
            case 5:  id(slot5_code)=0;  id(slot5_bits)=0;  break;
            case 6:  id(slot6_code)=0;  id(slot6_bits)=0;  break;
            case 7:  id(slot7_code)=0;  id(slot7_bits)=0;  break;
            case 8:  id(slot8_code)=0;  id(slot8_bits)=0;  break;
            case 9:  id(slot9_code)=0;  id(slot9_bits)=0;  break;
            case 10: id(slot10_code)=0; id(slot10_bits)=0; break;
            case 11: id(slot11_code)=0; id(slot11_bits)=0; break;
            case 12: id(slot12_code)=0; id(slot12_bits)=0; break;
            case 13: id(slot13_code)=0; id(slot13_bits)=0; break;
            case 14: id(slot14_code)=0; id(slot14_bits)=0; break;
            case 15: id(slot15_code)=0; id(slot15_bits)=0; break;
            case 16: id(slot16_code)=0; id(slot16_bits)=0; break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          ESP_LOGI("rf", "Cleared slot %d", s);

  - id: tx_slot_script
    mode: queued
    then:
      - lambda: |-
          const int s = (int) id(slot_select).state;
          uint64_t code = 0; uint8_t bits = 0;
          switch (s) {
            case 1:  code=id(slot1_code);  bits=id(slot1_bits);  break;
            case 2:  code=id(slot2_code);  bits=id(slot2_bits);  break;
            case 3:  code=id(slot3_code);  bits=id(slot3_bits);  break;
            case 4:  code=id(slot4_code);  bits=id(slot4_bits);  break;
            case 5:  code=id(slot5_code);  bits=id(slot5_bits);  break;
            case 6:  code=id(slot6_code);  bits=id(slot6_bits);  break;
            case 7:  code=id(slot7_code);  bits=id(slot7_bits);  break;
            case 8:  code=id(slot8_code);  bits=id(slot8_bits);  break;
            case 9:  code=id(slot9_code);  bits=id(slot9_bits);  break;
            case 10: code=id(slot10_code); bits=id(slot10_bits); break;
            case 11: code=id(slot11_code); bits=id(slot11_bits); break;
            case 12: code=id(slot12_code); bits=id(slot12_bits); break;
            case 13: code=id(slot13_code); bits=id(slot13_bits); break;
            case 14: code=id(slot14_code); bits=id(slot14_bits); break;
            case 15: code=id(slot15_code); bits=id(slot15_bits); break;
            case 16: code=id(slot16_code); bits=id(slot16_bits); break;
            default: ESP_LOGW("rf", "Slot out of range"); return;
          }
          if (code == 0 || bits == 0) {
            ESP_LOGW("rf", "Slot %d empty", s);
            return;
          }
          std::string bin; bin.reserve(bits);
          for (int i = bits - 1; i >= 0; --i)
            bin.push_back((code & (1ULL << i)) ? '1' : '0');
          id(learned_bin) = bin;

      - if:
          condition:
            lambda: 'return (uint32_t) id(rf_pulse_len).state < 325;'
          then:
            - script.execute: send_rc_switch_300
          else:
            - if:
                condition:
                  lambda: 'return (uint32_t) id(rf_pulse_len).state < 392;'
                then:
                  - script.execute: send_rc_switch_350
                else:
                  - script.execute: send_rc_switch_433

  # helper scripts for rc_switch protocols
  - id: send_rc_switch_300
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,10], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [30,71], zero: [4,11], one: [9,6] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,6], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [6,14], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 300, sync: [1,23], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

  - id: send_rc_switch_350
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,10], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [30,71], zero: [4,11], one: [9,6] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,6], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [6,14], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 350, sync: [1,23], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

  - id: send_rc_switch_433
    mode: parallel
    then:
      - if:
          condition:
            lambda: 'return id(rf_protocol_select).state == "Auto (rc_switch)" || id(rf_protocol_select).state == "Protocol 1";'
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,31], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 2";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,10], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 3";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [30,71], zero: [4,11], one: [9,6] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 4";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,6], zero: [1,3], one: [3,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 5";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [6,14], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'
      - if:
          condition: { lambda: 'return id(rf_protocol_select).state == "Protocol 6";' }
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda 'return id(learned_bin);'
                protocol: { pulse_length: 433, sync: [1,23], zero: [1,2], one: [2,1] }
                repeat: !lambda 'return (uint32_t) id(rf_repeat).state;'

# -------------------------------------------------------------------
# Logging / API
# -------------------------------------------------------------------
logger:
  level: DEBUG

api:
